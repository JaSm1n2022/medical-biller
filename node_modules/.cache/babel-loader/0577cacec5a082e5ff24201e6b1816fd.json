{"ast":null,"code":"import _regeneratorRuntime from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport crossFetch, { Headers as CrossFetchHeaders } from 'cross-fetch';\nexport var resolveFetch = function resolveFetch(customFetch) {\n  var _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === 'undefined') {\n    _fetch = crossFetch;\n  } else {\n    _fetch = fetch;\n  }\n  return function () {\n    return _fetch.apply(void 0, arguments);\n  };\n};\nexport var resolveHeadersConstructor = function resolveHeadersConstructor() {\n  if (typeof Headers === 'undefined') {\n    return CrossFetchHeaders;\n  }\n  return Headers;\n};\nexport var fetchWithAuth = function fetchWithAuth(supabaseKey, getAccessToken, customFetch) {\n  var fetch = resolveFetch(customFetch);\n  var HeadersConstructor = resolveHeadersConstructor();\n  return function (input, init) {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var _a, accessToken, headers;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return getAccessToken();\n          case 2:\n            _context.t1 = _a = _context.sent;\n            _context.t0 = _context.t1 !== null;\n            if (!_context.t0) {\n              _context.next = 6;\n              break;\n            }\n            _context.t0 = _a !== void 0;\n          case 6:\n            if (!_context.t0) {\n              _context.next = 10;\n              break;\n            }\n            _context.t2 = _a;\n            _context.next = 11;\n            break;\n          case 10:\n            _context.t2 = supabaseKey;\n          case 11:\n            accessToken = _context.t2;\n            headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n            if (!headers.has('apikey')) {\n              headers.set('apikey', supabaseKey);\n            }\n            if (!headers.has('Authorization')) {\n              headers.set('Authorization', \"Bearer \".concat(accessToken));\n            }\n            return _context.abrupt(\"return\", fetch(input, Object.assign(Object.assign({}, init), {\n              headers: headers\n            })));\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n  };\n};","map":{"version":3,"sources":["../../../src/lib/fetch.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,UAAU,IAAI,OAAO,IAAI,iBAAiB,QAAQ,aAAa;AAItE,OAAO,IAAM,YAAY,GAAG,SAAf,YAAY,CAAI,WAAmB,EAAW;EACzD,IAAI,MAAa;EACjB,IAAI,WAAW,EAAE;IACf,MAAM,GAAG,WAAW;GACrB,MAAM,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;IACvC,MAAM,GAAG,UAA8B;GACxC,MAAM;IACL,MAAM,GAAG,KAAK;EACf;EACD,OAAO;IAAA,OAAa,MAAM,CAAA,KAAA,SAAA,SAAQ,CAAC;EAAA;AACrC,CAAC;AAED,OAAO,IAAM,yBAAyB,GAAG,SAA5B,yBAAyB,CAAA,EAAQ;EAC5C,IAAI,OAAO,OAAO,KAAK,WAAW,EAAE;IAClC,OAAO,iBAAiB;EACzB;EAED,OAAO,OAAO;AAChB,CAAC;AAED,OAAO,IAAM,aAAa,GAAG,SAAhB,aAAa,CACxB,WAAmB,EACnB,cAA4C,EAC5C,WAAmB,EACV;EACT,IAAM,KAAK,GAAG,YAAY,CAAC,WAAW,CAAC;EACvC,IAAM,kBAAkB,GAAG,yBAAyB,CAAA,CAAE;EAEtD,OAAO,UAAO,KAAK,EAAE,IAAI;IAAA,OAAI,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,eAAA,mBAAA,GAAA,IAAA,CAAA,SAAA,QAAA;MAAA,IAAA,EAAA,EAAA,WAAA,EAAA,OAAA;MAAA,OAAA,mBAAA,GAAA,IAAA,UAAA,SAAA,QAAA;QAAA,kBAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;UAAA;YAAA,QAAA,CAAA,IAAA;YACN,OAAM,cAAc,CAAA,CAAE;UAAA;YAAA,QAAA,CAAA,EAAA,GAAvB,EAAA,GAAA,QAAA,CAAA,IAAA;YAAA,QAAA,CAAA,EAAA,GAAA,QAAA,CAAA,EAAA,KAAwB,IAAA;YAAA,KAAA,QAAA,CAAA,EAAA;cAAA,QAAA,CAAA,IAAA;cAAA;YAAA;YAAA,QAAA,CAAA,EAAA,GAAA,EAAA,KAAA,KAAA,CAAA;UAAA;YAAA,KAAA,QAAA,CAAA,EAAA;cAAA,QAAA,CAAA,IAAA;cAAA;YAAA;YAAA,QAAA,CAAA,EAAA,GAAA,EAAA;YAAA,QAAA,CAAA,IAAA;YAAA;UAAA;YAAA,QAAA,CAAA,EAAA,GAAI,WAAW;UAAA;YAArD,WAAW,GAAA,QAAA,CAAA,EAAA;YACb,OAAO,GAAG,IAAI,kBAAkB,CAAC,IAAI,KAAA,IAAA,IAAJ,IAAI,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAJ,IAAI,CAAE,OAAO,CAAC;YAEnD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;cAC1B,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,WAAW,CAAC;YACnC;YAED,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,EAAE;cACjC,OAAO,CAAC,GAAG,CAAC,eAAe,YAAA,MAAA,CAAY,WAAW,CAAE,CAAC;;YACtD,OAAA,QAAA,CAAA,MAAA,WAEM,KAAK,CAAC,KAAK,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAO,IAAI,CAAA,EAAA;cAAE,OAAO,EAAP;YAAO,CAAA,CAAA,CAAG;UAAA;UAAA;YAAA,OAAA,QAAA,CAAA,IAAA;QAAA;MAAA,GAAA,OAAA;IAAA,CAC1C,EAAA;EAAA;AACH,CAAC","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport crossFetch, { Headers as CrossFetchHeaders } from 'cross-fetch';\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = crossFetch;\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nexport const resolveHeadersConstructor = () => {\n    if (typeof Headers === 'undefined') {\n        return CrossFetchHeaders;\n    }\n    return Headers;\n};\nexport const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n    const fetch = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return (input, init) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const accessToken = (_a = (yield getAccessToken())) !== null && _a !== void 0 ? _a : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has('apikey')) {\n            headers.set('apikey', supabaseKey);\n        }\n        if (!headers.has('Authorization')) {\n            headers.set('Authorization', `Bearer ${accessToken}`);\n        }\n        return fetch(input, Object.assign(Object.assign({}, init), { headers }));\n    });\n};\n//# sourceMappingURL=fetch.js.map"]},"metadata":{},"sourceType":"module"}