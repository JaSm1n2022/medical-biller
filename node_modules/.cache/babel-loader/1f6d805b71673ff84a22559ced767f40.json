{"ast":null,"code":"import _classCallCheck from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport PostgrestBuilder from './PostgrestBuilder';\nvar PostgrestTransformBuilder = /*#__PURE__*/function (_PostgrestBuilder) {\n  _inherits(PostgrestTransformBuilder, _PostgrestBuilder);\n  var _super = _createSuper(PostgrestTransformBuilder);\n  function PostgrestTransformBuilder() {\n    _classCallCheck(this, PostgrestTransformBuilder);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PostgrestTransformBuilder, [{\n    key: \"select\",\n    value:\n    /**\n     * Perform a SELECT on the query result.\n     *\n     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n     * return modified rows. By calling this method, modified rows are returned in\n     * `data`.\n     *\n     * @param columns - The columns to retrieve, separated by commas\n     */\n    function select(columns) {\n      // Remove whitespaces except when quoted\n      var quoted = false;\n      var cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(function (c) {\n        if (/\\s/.test(c) && !quoted) {\n          return '';\n        }\n        if (c === '\"') {\n          quoted = !quoted;\n        }\n        return c;\n      }).join('');\n      this.url.searchParams.set('select', cleanedColumns);\n      if (this.headers['Prefer']) {\n        this.headers['Prefer'] += ',';\n      }\n      this.headers['Prefer'] += 'return=representation';\n      return this;\n    }\n    /**\n     * Order the query result by `column`.\n     *\n     * You can call this method multiple times to order by multiple columns.\n     *\n     * You can order foreign tables, but it doesn't affect the ordering of the\n     * current table.\n     *\n     * @param column - The column to order by\n     * @param options - Named parameters\n     * @param options.ascending - If `true`, the result will be in ascending order\n     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n     * `null`s appear last.\n     * @param options.foreignTable - Set this to order a foreign table by foreign\n     * columns\n     */\n  }, {\n    key: \"order\",\n    value: function order(column) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$ascending = _ref.ascending,\n        ascending = _ref$ascending === void 0 ? true : _ref$ascending,\n        nullsFirst = _ref.nullsFirst,\n        foreignTable = _ref.foreignTable;\n      var key = foreignTable ? \"\".concat(foreignTable, \".order\") : 'order';\n      var existingOrder = this.url.searchParams.get(key);\n      this.url.searchParams.set(key, \"\".concat(existingOrder ? \"\".concat(existingOrder, \",\") : '').concat(column, \".\").concat(ascending ? 'asc' : 'desc').concat(nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'));\n      return this;\n    }\n    /**\n     * Limit the query result by `count`.\n     *\n     * @param count - The maximum number of rows to return\n     * @param options - Named parameters\n     * @param options.foreignTable - Set this to limit rows of foreign tables\n     * instead of the current table\n     */\n  }, {\n    key: \"limit\",\n    value: function limit(count) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        foreignTable = _ref2.foreignTable;\n      var key = typeof foreignTable === 'undefined' ? 'limit' : \"\".concat(foreignTable, \".limit\");\n      this.url.searchParams.set(key, \"\".concat(count));\n      return this;\n    }\n    /**\n     * Limit the query result by `from` and `to` inclusively.\n     *\n     * @param from - The starting index from which to limit the result\n     * @param to - The last index to which to limit the result\n     * @param options - Named parameters\n     * @param options.foreignTable - Set this to limit rows of foreign tables\n     * instead of the current table\n     */\n  }, {\n    key: \"range\",\n    value: function range(from, to) {\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        foreignTable = _ref3.foreignTable;\n      var keyOffset = typeof foreignTable === 'undefined' ? 'offset' : \"\".concat(foreignTable, \".offset\");\n      var keyLimit = typeof foreignTable === 'undefined' ? 'limit' : \"\".concat(foreignTable, \".limit\");\n      this.url.searchParams.set(keyOffset, \"\".concat(from));\n      // Range is inclusive, so add 1\n      this.url.searchParams.set(keyLimit, \"\".concat(to - from + 1));\n      return this;\n    }\n    /**\n     * Set the AbortSignal for the fetch request.\n     *\n     * @param signal - The AbortSignal to use for the fetch request\n     */\n  }, {\n    key: \"abortSignal\",\n    value: function abortSignal(signal) {\n      this.signal = signal;\n      return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n     * returns an error.\n     */\n  }, {\n    key: \"single\",\n    value: function single() {\n      this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n      return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n     * this returns an error.\n     */\n  }, {\n    key: \"maybeSingle\",\n    value: function maybeSingle() {\n      this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n      this.allowEmpty = true;\n      return this;\n    }\n    /**\n     * Return `data` as a string in CSV format.\n     */\n  }, {\n    key: \"csv\",\n    value: function csv() {\n      this.headers['Accept'] = 'text/csv';\n      return this;\n    }\n    /**\n     * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n     */\n  }, {\n    key: \"geojson\",\n    value: function geojson() {\n      this.headers['Accept'] = 'application/geo+json';\n      return this;\n    }\n    /**\n     * Return `data` as the EXPLAIN plan for the query.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.analyze - If `true`, the query will be executed and the\n     * actual run time will be returned\n     *\n     * @param options.verbose - If `true`, the query identifier will be returned\n     * and `data` will include the output columns of the query\n     *\n     * @param options.settings - If `true`, include information on configuration\n     * parameters that affect query planning\n     *\n     * @param options.buffers - If `true`, include information on buffer usage\n     *\n     * @param options.wal - If `true`, include information on WAL record generation\n     *\n     * @param options.format - The format of the output, can be `\"text\"` (default)\n     * or `\"json\"`\n     */\n  }, {\n    key: \"explain\",\n    value: function explain() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$analyze = _ref4.analyze,\n        analyze = _ref4$analyze === void 0 ? false : _ref4$analyze,\n        _ref4$verbose = _ref4.verbose,\n        verbose = _ref4$verbose === void 0 ? false : _ref4$verbose,\n        _ref4$settings = _ref4.settings,\n        settings = _ref4$settings === void 0 ? false : _ref4$settings,\n        _ref4$buffers = _ref4.buffers,\n        buffers = _ref4$buffers === void 0 ? false : _ref4$buffers,\n        _ref4$wal = _ref4.wal,\n        wal = _ref4$wal === void 0 ? false : _ref4$wal,\n        _ref4$format = _ref4.format,\n        format = _ref4$format === void 0 ? 'text' : _ref4$format;\n      var options = [analyze ? 'analyze' : null, verbose ? 'verbose' : null, settings ? 'settings' : null, buffers ? 'buffers' : null, wal ? 'wal' : null].filter(Boolean).join('|');\n      // An Accept header can carry multiple media types but postgrest-js always sends one\n      var forMediatype = this.headers['Accept'];\n      this.headers['Accept'] = \"application/vnd.pgrst.plan+\".concat(format, \"; for=\\\"\").concat(forMediatype, \"\\\"; options=\").concat(options, \";\");\n      if (format === 'json') return this;else return this;\n    }\n    /**\n     * Rollback the query.\n     *\n     * `data` will still be returned, but the query is not committed.\n     */\n  }, {\n    key: \"rollback\",\n    value: function rollback() {\n      var _a;\n      if (((_a = this.headers['Prefer']) !== null && _a !== void 0 ? _a : '').trim().length > 0) {\n        this.headers['Prefer'] += ',tx=rollback';\n      } else {\n        this.headers['Prefer'] = 'tx=rollback';\n      }\n      return this;\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     */\n  }, {\n    key: \"returns\",\n    value: function returns() {\n      return this;\n    }\n  }]);\n  return PostgrestTransformBuilder;\n}(PostgrestBuilder);\nexport { PostgrestTransformBuilder as default };","map":{"version":3,"sources":["../../src/PostgrestTransformBuilder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import PostgrestBuilder from './PostgrestBuilder';\nexport default class PostgrestTransformBuilder extends PostgrestBuilder {\n    /**\n     * Perform a SELECT on the query result.\n     *\n     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n     * return modified rows. By calling this method, modified rows are returned in\n     * `data`.\n     *\n     * @param columns - The columns to retrieve, separated by commas\n     */\n    select(columns) {\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (this.headers['Prefer']) {\n            this.headers['Prefer'] += ',';\n        }\n        this.headers['Prefer'] += 'return=representation';\n        return this;\n    }\n    /**\n     * Order the query result by `column`.\n     *\n     * You can call this method multiple times to order by multiple columns.\n     *\n     * You can order foreign tables, but it doesn't affect the ordering of the\n     * current table.\n     *\n     * @param column - The column to order by\n     * @param options - Named parameters\n     * @param options.ascending - If `true`, the result will be in ascending order\n     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n     * `null`s appear last.\n     * @param options.foreignTable - Set this to order a foreign table by foreign\n     * columns\n     */\n    order(column, { ascending = true, nullsFirst, foreignTable, } = {}) {\n        const key = foreignTable ? `${foreignTable}.order` : 'order';\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'}`);\n        return this;\n    }\n    /**\n     * Limit the query result by `count`.\n     *\n     * @param count - The maximum number of rows to return\n     * @param options - Named parameters\n     * @param options.foreignTable - Set this to limit rows of foreign tables\n     * instead of the current table\n     */\n    limit(count, { foreignTable } = {}) {\n        const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n     * Limit the query result by `from` and `to` inclusively.\n     *\n     * @param from - The starting index from which to limit the result\n     * @param to - The last index to which to limit the result\n     * @param options - Named parameters\n     * @param options.foreignTable - Set this to limit rows of foreign tables\n     * instead of the current table\n     */\n    range(from, to, { foreignTable } = {}) {\n        const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`;\n        const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        // Range is inclusive, so add 1\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n     * Set the AbortSignal for the fetch request.\n     *\n     * @param signal - The AbortSignal to use for the fetch request\n     */\n    abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n     * returns an error.\n     */\n    single() {\n        this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n     * this returns an error.\n     */\n    maybeSingle() {\n        this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n        this.allowEmpty = true;\n        return this;\n    }\n    /**\n     * Return `data` as a string in CSV format.\n     */\n    csv() {\n        this.headers['Accept'] = 'text/csv';\n        return this;\n    }\n    /**\n     * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n     */\n    geojson() {\n        this.headers['Accept'] = 'application/geo+json';\n        return this;\n    }\n    /**\n     * Return `data` as the EXPLAIN plan for the query.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.analyze - If `true`, the query will be executed and the\n     * actual run time will be returned\n     *\n     * @param options.verbose - If `true`, the query identifier will be returned\n     * and `data` will include the output columns of the query\n     *\n     * @param options.settings - If `true`, include information on configuration\n     * parameters that affect query planning\n     *\n     * @param options.buffers - If `true`, include information on buffer usage\n     *\n     * @param options.wal - If `true`, include information on WAL record generation\n     *\n     * @param options.format - The format of the output, can be `\"text\"` (default)\n     * or `\"json\"`\n     */\n    explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = 'text', } = {}) {\n        const options = [\n            analyze ? 'analyze' : null,\n            verbose ? 'verbose' : null,\n            settings ? 'settings' : null,\n            buffers ? 'buffers' : null,\n            wal ? 'wal' : null,\n        ]\n            .filter(Boolean)\n            .join('|');\n        // An Accept header can carry multiple media types but postgrest-js always sends one\n        const forMediatype = this.headers['Accept'];\n        this.headers['Accept'] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`;\n        if (format === 'json')\n            return this;\n        else\n            return this;\n    }\n    /**\n     * Rollback the query.\n     *\n     * `data` will still be returned, but the query is not committed.\n     */\n    rollback() {\n        var _a;\n        if (((_a = this.headers['Prefer']) !== null && _a !== void 0 ? _a : '').trim().length > 0) {\n            this.headers['Prefer'] += ',tx=rollback';\n        }\n        else {\n            this.headers['Prefer'] = 'tx=rollback';\n        }\n        return this;\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     */\n    returns() {\n        return this;\n    }\n}\n//# sourceMappingURL=PostgrestTransformBuilder.js.map"]},"metadata":{},"sourceType":"module"}