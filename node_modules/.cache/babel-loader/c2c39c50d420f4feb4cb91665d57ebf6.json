{"ast":null,"code":"import _classCallCheck from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { DEFAULT_TIMEOUT } from '../lib/constants';\nvar Push = /*#__PURE__*/function () {\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  function Push(channel, event) {\n    var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_TIMEOUT;\n    _classCallCheck(this, Push);\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload;\n    this.timeout = timeout;\n    this.sent = false;\n    this.timeoutTimer = undefined;\n    this.ref = '';\n    this.receivedResp = null;\n    this.recHooks = [];\n    this.refEvent = null;\n    this.rateLimited = false;\n  }\n  _createClass(Push, [{\n    key: \"resend\",\n    value: function resend(timeout) {\n      this.timeout = timeout;\n      this._cancelRefEvent();\n      this.ref = '';\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n      this.send();\n    }\n  }, {\n    key: \"send\",\n    value: function send() {\n      if (this._hasReceived('timeout')) {\n        return;\n      }\n      this.startTimeout();\n      this.sent = true;\n      var status = this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload,\n        ref: this.ref,\n        join_ref: this.channel._joinRef()\n      });\n      if (status === 'rate limited') {\n        this.rateLimited = true;\n      }\n    }\n  }, {\n    key: \"updatePayload\",\n    value: function updatePayload(payload) {\n      this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n  }, {\n    key: \"receive\",\n    value: function receive(status, callback) {\n      var _a;\n      if (this._hasReceived(status)) {\n        callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n      }\n      this.recHooks.push({\n        status: status,\n        callback: callback\n      });\n      return this;\n    }\n  }, {\n    key: \"startTimeout\",\n    value: function startTimeout() {\n      var _this = this;\n      if (this.timeoutTimer) {\n        return;\n      }\n      this.ref = this.channel.socket._makeRef();\n      this.refEvent = this.channel._replyEventName(this.ref);\n      var callback = function callback(payload) {\n        _this._cancelRefEvent();\n        _this._cancelTimeout();\n        _this.receivedResp = payload;\n        _this._matchReceive(payload);\n      };\n      this.channel._on(this.refEvent, {}, callback);\n      this.timeoutTimer = setTimeout(function () {\n        _this.trigger('timeout', {});\n      }, this.timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(status, response) {\n      if (this.refEvent) this.channel._trigger(this.refEvent, {\n        status: status,\n        response: response\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._cancelRefEvent();\n      this._cancelTimeout();\n    }\n  }, {\n    key: \"_cancelRefEvent\",\n    value: function _cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n      this.channel._off(this.refEvent, {});\n    }\n  }, {\n    key: \"_cancelTimeout\",\n    value: function _cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = undefined;\n    }\n  }, {\n    key: \"_matchReceive\",\n    value: function _matchReceive(_ref) {\n      var status = _ref.status,\n        response = _ref.response;\n      this.recHooks.filter(function (h) {\n        return h.status === status;\n      }).forEach(function (h) {\n        return h.callback(response);\n      });\n    }\n  }, {\n    key: \"_hasReceived\",\n    value: function _hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n  }]);\n  return Push;\n}();\nexport { Push as default };","map":{"version":3,"sources":["../../../src/lib/push.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DEFAULT_TIMEOUT } from '../lib/constants';\nexport default class Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */\n    constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = '';\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n        this.rateLimited = false;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = '';\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived('timeout')) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        const status = this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef(),\n        });\n        if (status === 'rate limited') {\n            this.rateLimited = true;\n        }\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({ status, callback });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload) => {\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(() => {\n            this.trigger('timeout', {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent)\n            this.channel._trigger(this.refEvent, { status, response });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response, }) {\n        this.recHooks\n            .filter((h) => h.status === status)\n            .forEach((h) => h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\n//# sourceMappingURL=push.js.map"]},"metadata":{},"sourceType":"module"}