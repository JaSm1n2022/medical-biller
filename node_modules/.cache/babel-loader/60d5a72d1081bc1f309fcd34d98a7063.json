{"ast":null,"code":"import _regeneratorRuntime from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthPKCEGrantCodeExchangeError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep, generatePKCEVerifier, generatePKCEChallenge } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit'\n};\n/** Current session will be checked for refresh at this interval. */\nvar AUTO_REFRESH_TICK_DURATION = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nvar AUTO_REFRESH_TICK_THRESHOLD = 3;\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   */\n  function GoTrueClient(options) {\n    var _this = this;\n    _classCallCheck(this, GoTrueClient);\n    var _a;\n    this.stateChangeEmitters = new Map();\n    this.autoRefreshTicker = null;\n    this.visibilityChangedCallback = null;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    /**\n     * Used to broadcast state change events to other tabs listening.\n     */\n    this.broadcastChannel = null;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.flowType = settings.flowType;\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n      } catch (e) {\n        console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n      }\n      (_a = this.broadcastChannel) === null || _a === void 0 ? void 0 : _a.addEventListener('message', function (event) {\n        _this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n      });\n    }\n\n    this.initialize();\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  _createClass(GoTrueClient, [{\n    key: \"initialize\",\n    value: function initialize() {\n      if (!this.initializePromise) {\n        this.initializePromise = this._initialize();\n      }\n      return this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n        var isPKCEFlow, _yield$this$_getSessi, data, error, session, redirectType;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.initializePromise) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", this.initializePromise);\n            case 2:\n              _context.prev = 2;\n              _context.next = 5;\n              return this._isPKCEFlow();\n            case 5:\n              isPKCEFlow = _context.sent;\n              if (!(this.detectSessionInUrl && this._isImplicitGrantFlow() || isPKCEFlow)) {\n                _context.next = 21;\n                break;\n              }\n              _context.next = 9;\n              return this._getSessionFromUrl(isPKCEFlow);\n            case 9:\n              _yield$this$_getSessi = _context.sent;\n              data = _yield$this$_getSessi.data;\n              error = _yield$this$_getSessi.error;\n              if (!error) {\n                _context.next = 16;\n                break;\n              }\n              _context.next = 15;\n              return this._removeSession();\n            case 15:\n              return _context.abrupt(\"return\", {\n                error: error\n              });\n            case 16:\n              session = data.session, redirectType = data.redirectType;\n              _context.next = 19;\n              return this._saveSession(session);\n            case 19:\n              setTimeout(function () {\n                if (redirectType === 'recovery') {\n                  _this2._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                } else {\n                  _this2._notifyAllSubscribers('SIGNED_IN', session);\n                }\n              }, 0);\n              return _context.abrupt(\"return\", {\n                error: null\n              });\n            case 21:\n              _context.next = 23;\n              return this._recoverAndRefresh();\n            case 23:\n              return _context.abrupt(\"return\", {\n                error: null\n              });\n            case 26:\n              _context.prev = 26;\n              _context.t0 = _context[\"catch\"](2);\n              if (!isAuthError(_context.t0)) {\n                _context.next = 30;\n                break;\n              }\n              return _context.abrupt(\"return\", {\n                error: _context.t0\n              });\n            case 30:\n              return _context.abrupt(\"return\", {\n                error: new AuthUnknownError('Unexpected error during initialization', _context.t0)\n              });\n            case 31:\n              _context.prev = 31;\n              _context.next = 34;\n              return this._handleVisibilityChange();\n            case 34:\n              return _context.finish(31);\n            case 35:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2, 26, 31, 35]]);\n      }));\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n  }, {\n    key: \"signUp\",\n    value: function signUp(credentials) {\n      var _a, _b, _c;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var res, email, password, options, codeChallenge, codeChallengeMethod, codeVerifier, phone, _password, _options, _res, data, error, session, user;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return this._removeSession();\n            case 3:\n              if (!('email' in credentials)) {\n                _context2.next = 20;\n                break;\n              }\n              email = credentials.email, password = credentials.password, options = credentials.options;\n              codeChallenge = null;\n              codeChallengeMethod = null;\n              if (!(this.flowType === 'pkce')) {\n                _context2.next = 15;\n                break;\n              }\n              codeVerifier = generatePKCEVerifier();\n              _context2.next = 11;\n              return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n            case 11:\n              _context2.next = 13;\n              return generatePKCEChallenge(codeVerifier);\n            case 13:\n              codeChallenge = _context2.sent;\n              codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n            case 15:\n              _context2.next = 17;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                headers: this.headers,\n                redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                body: {\n                  email: email,\n                  password: password,\n                  data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  },\n                  code_challenge: codeChallenge,\n                  code_challenge_method: codeChallengeMethod\n                },\n                xform: _sessionResponse\n              });\n            case 17:\n              res = _context2.sent;\n              _context2.next = 28;\n              break;\n            case 20:\n              if (!('phone' in credentials)) {\n                _context2.next = 27;\n                break;\n              }\n              phone = credentials.phone, _password = credentials.password, _options = credentials.options;\n              _context2.next = 24;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                headers: this.headers,\n                body: {\n                  phone: phone,\n                  password: _password,\n                  data: (_b = _options === null || _options === void 0 ? void 0 : _options.data) !== null && _b !== void 0 ? _b : {},\n                  channel: (_c = _options === null || _options === void 0 ? void 0 : _options.channel) !== null && _c !== void 0 ? _c : 'sms',\n                  gotrue_meta_security: {\n                    captcha_token: _options === null || _options === void 0 ? void 0 : _options.captchaToken\n                  }\n                },\n                xform: _sessionResponse\n              });\n            case 24:\n              res = _context2.sent;\n              _context2.next = 28;\n              break;\n            case 27:\n              throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n            case 28:\n              _res = res, data = _res.data, error = _res.error;\n              if (!(error || !data)) {\n                _context2.next = 31;\n                break;\n              }\n              return _context2.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 31:\n              session = data.session;\n              user = data.user;\n              if (!data.session) {\n                _context2.next = 37;\n                break;\n              }\n              _context2.next = 36;\n              return this._saveSession(data.session);\n            case 36:\n              this._notifyAllSubscribers('SIGNED_IN', session);\n            case 37:\n              return _context2.abrupt(\"return\", {\n                data: {\n                  user: user,\n                  session: session\n                },\n                error: null\n              });\n            case 40:\n              _context2.prev = 40;\n              _context2.t0 = _context2[\"catch\"](0);\n              if (!isAuthError(_context2.t0)) {\n                _context2.next = 44;\n                break;\n              }\n              return _context2.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context2.t0\n              });\n            case 44:\n              throw _context2.t0;\n            case 45:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[0, 40]]);\n      }));\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */\n  }, {\n    key: \"signInWithPassword\",\n    value: function signInWithPassword(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var res, email, password, options, phone, _password2, _options2, _res2, data, error;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.next = 3;\n              return this._removeSession();\n            case 3:\n              if (!('email' in credentials)) {\n                _context3.next = 10;\n                break;\n              }\n              email = credentials.email, password = credentials.password, options = credentials.options;\n              _context3.next = 7;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                headers: this.headers,\n                body: {\n                  email: email,\n                  password: password,\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  }\n                },\n                xform: _sessionResponse\n              });\n            case 7:\n              res = _context3.sent;\n              _context3.next = 18;\n              break;\n            case 10:\n              if (!('phone' in credentials)) {\n                _context3.next = 17;\n                break;\n              }\n              phone = credentials.phone, _password2 = credentials.password, _options2 = credentials.options;\n              _context3.next = 14;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                headers: this.headers,\n                body: {\n                  phone: phone,\n                  password: _password2,\n                  gotrue_meta_security: {\n                    captcha_token: _options2 === null || _options2 === void 0 ? void 0 : _options2.captchaToken\n                  }\n                },\n                xform: _sessionResponse\n              });\n            case 14:\n              res = _context3.sent;\n              _context3.next = 18;\n              break;\n            case 17:\n              throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n            case 18:\n              _res2 = res, data = _res2.data, error = _res2.error;\n              if (!(error || !data)) {\n                _context3.next = 21;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 21:\n              if (!data.session) {\n                _context3.next = 25;\n                break;\n              }\n              _context3.next = 24;\n              return this._saveSession(data.session);\n            case 24:\n              this._notifyAllSubscribers('SIGNED_IN', data.session);\n            case 25:\n              return _context3.abrupt(\"return\", {\n                data: data,\n                error: error\n              });\n            case 28:\n              _context3.prev = 28;\n              _context3.t0 = _context3[\"catch\"](0);\n              if (!isAuthError(_context3.t0)) {\n                _context3.next = 32;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context3.t0\n              });\n            case 32:\n              throw _context3.t0;\n            case 33:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[0, 28]]);\n      }));\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n  }, {\n    key: \"signInWithOAuth\",\n    value: function signInWithOAuth(credentials) {\n      var _a, _b, _c, _d;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this._removeSession();\n            case 2:\n              _context4.next = 4;\n              return this._handleProviderSignIn(credentials.provider, {\n                redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n              });\n            case 4:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n  }, {\n    key: \"exchangeCodeForSession\",\n    value: function exchangeCodeForSession(authCode) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var codeVerifier, _yield$_request, data, error;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return getItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            case 2:\n              codeVerifier = _context5.sent;\n              _context5.next = 5;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=pkce\"), {\n                headers: this.headers,\n                body: {\n                  auth_code: authCode,\n                  code_verifier: codeVerifier\n                },\n                xform: _sessionResponse\n              });\n            case 5:\n              _yield$_request = _context5.sent;\n              data = _yield$_request.data;\n              error = _yield$_request.error;\n              _context5.next = 10;\n              return removeItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            case 10:\n              if (!(error || !data)) {\n                _context5.next = 12;\n                break;\n              }\n              return _context5.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 12:\n              if (!data.session) {\n                _context5.next = 16;\n                break;\n              }\n              _context5.next = 15;\n              return this._saveSession(data.session);\n            case 15:\n              this._notifyAllSubscribers('SIGNED_IN', data.session);\n            case 16:\n              return _context5.abrupt(\"return\", {\n                data: data,\n                error: error\n              });\n            case 17:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Allows signing in with an ID token issued by certain supported providers.\n     * The ID token is verified for validity and a new session is established.\n     *\n     * @experimental\n     */\n  }, {\n    key: \"signInWithIdToken\",\n    value: function signInWithIdToken(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var options, provider, token, nonce, res, data, error;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this._removeSession();\n            case 2:\n              _context6.prev = 2;\n              options = credentials.options, provider = credentials.provider, token = credentials.token, nonce = credentials.nonce;\n              _context6.next = 6;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=id_token\"), {\n                headers: this.headers,\n                body: {\n                  provider: provider,\n                  id_token: token,\n                  nonce: nonce,\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  }\n                },\n                xform: _sessionResponse\n              });\n            case 6:\n              res = _context6.sent;\n              data = res.data, error = res.error;\n              if (!(error || !data)) {\n                _context6.next = 10;\n                break;\n              }\n              return _context6.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 10:\n              if (!data.session) {\n                _context6.next = 14;\n                break;\n              }\n              _context6.next = 13;\n              return this._saveSession(data.session);\n            case 13:\n              this._notifyAllSubscribers('SIGNED_IN', data.session);\n            case 14:\n              return _context6.abrupt(\"return\", {\n                data: data,\n                error: error\n              });\n            case 17:\n              _context6.prev = 17;\n              _context6.t0 = _context6[\"catch\"](2);\n              if (!isAuthError(_context6.t0)) {\n                _context6.next = 21;\n                break;\n              }\n              return _context6.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context6.t0\n              });\n            case 21:\n              throw _context6.t0;\n            case 22:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[2, 17]]);\n      }));\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     */\n  }, {\n    key: \"signInWithOtp\",\n    value: function signInWithOtp(credentials) {\n      var _a, _b, _c, _d, _e;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var email, options, codeChallenge, codeChallengeMethod, codeVerifier, _yield$_request2, error, phone, _options3, _yield$_request3, _error;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.prev = 0;\n              _context7.next = 3;\n              return this._removeSession();\n            case 3:\n              if (!('email' in credentials)) {\n                _context7.next = 20;\n                break;\n              }\n              email = credentials.email, options = credentials.options;\n              codeChallenge = null;\n              codeChallengeMethod = null;\n              if (!(this.flowType === 'pkce')) {\n                _context7.next = 15;\n                break;\n              }\n              codeVerifier = generatePKCEVerifier();\n              _context7.next = 11;\n              return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n            case 11:\n              _context7.next = 13;\n              return generatePKCEChallenge(codeVerifier);\n            case 13:\n              codeChallenge = _context7.sent;\n              codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n            case 15:\n              _context7.next = 17;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                headers: this.headers,\n                body: {\n                  email: email,\n                  data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                  create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  },\n                  code_challenge: codeChallenge,\n                  code_challenge_method: codeChallengeMethod\n                },\n                redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n              });\n            case 17:\n              _yield$_request2 = _context7.sent;\n              error = _yield$_request2.error;\n              return _context7.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 20:\n              if (!('phone' in credentials)) {\n                _context7.next = 27;\n                break;\n              }\n              phone = credentials.phone, _options3 = credentials.options;\n              _context7.next = 24;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                headers: this.headers,\n                body: {\n                  phone: phone,\n                  data: (_c = _options3 === null || _options3 === void 0 ? void 0 : _options3.data) !== null && _c !== void 0 ? _c : {},\n                  create_user: (_d = _options3 === null || _options3 === void 0 ? void 0 : _options3.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                  gotrue_meta_security: {\n                    captcha_token: _options3 === null || _options3 === void 0 ? void 0 : _options3.captchaToken\n                  },\n                  channel: (_e = _options3 === null || _options3 === void 0 ? void 0 : _options3.channel) !== null && _e !== void 0 ? _e : 'sms'\n                }\n              });\n            case 24:\n              _yield$_request3 = _context7.sent;\n              _error = _yield$_request3.error;\n              return _context7.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _error\n              });\n            case 27:\n              throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n            case 30:\n              _context7.prev = 30;\n              _context7.t0 = _context7[\"catch\"](0);\n              if (!isAuthError(_context7.t0)) {\n                _context7.next = 34;\n                break;\n              }\n              return _context7.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context7.t0\n              });\n            case 34:\n              throw _context7.t0;\n            case 35:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[0, 30]]);\n      }));\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     */\n  }, {\n    key: \"verifyOtp\",\n    value: function verifyOtp(params) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _yield$_request4, data, error, session, user;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.prev = 0;\n              _context8.next = 3;\n              return this._removeSession();\n            case 3:\n              _context8.next = 5;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/verify\"), {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                  gotrue_meta_security: {\n                    captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n                  }\n                }),\n                redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                xform: _sessionResponse\n              });\n            case 5:\n              _yield$_request4 = _context8.sent;\n              data = _yield$_request4.data;\n              error = _yield$_request4.error;\n              if (!error) {\n                _context8.next = 10;\n                break;\n              }\n              throw error;\n            case 10:\n              if (data) {\n                _context8.next = 12;\n                break;\n              }\n              throw new Error('An error occurred on token verification.');\n            case 12:\n              session = data.session;\n              user = data.user;\n              if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n                _context8.next = 18;\n                break;\n              }\n              _context8.next = 17;\n              return this._saveSession(session);\n            case 17:\n              this._notifyAllSubscribers('SIGNED_IN', session);\n            case 18:\n              return _context8.abrupt(\"return\", {\n                data: {\n                  user: user,\n                  session: session\n                },\n                error: null\n              });\n            case 21:\n              _context8.prev = 21;\n              _context8.t0 = _context8[\"catch\"](0);\n              if (!isAuthError(_context8.t0)) {\n                _context8.next = 25;\n                break;\n              }\n              return _context8.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context8.t0\n              });\n            case 25:\n              throw _context8.t0;\n            case 26:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[0, 21]]);\n      }));\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */\n  }, {\n    key: \"signInWithSSO\",\n    value: function signInWithSSO(params) {\n      var _a, _b, _c;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.prev = 0;\n              _context9.next = 3;\n              return this._removeSession();\n            case 3:\n              _context9.next = 5;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/sso\"), {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n                  provider_id: params.providerId\n                } : null), 'domain' in params ? {\n                  domain: params.domain\n                } : null), {\n                  redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                  gotrue_meta_security: {\n                    captcha_token: params.options.captchaToken\n                  }\n                } : null), {\n                  skip_http_redirect: true\n                }),\n                headers: this.headers,\n                xform: _ssoResponse\n              });\n            case 5:\n              return _context9.abrupt(\"return\", _context9.sent);\n            case 8:\n              _context9.prev = 8;\n              _context9.t0 = _context9[\"catch\"](0);\n              if (!isAuthError(_context9.t0)) {\n                _context9.next = 12;\n                break;\n              }\n              return _context9.abrupt(\"return\", {\n                data: null,\n                error: _context9.t0\n              });\n            case 12:\n              throw _context9.t0;\n            case 13:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[0, 8]]);\n      }));\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     */\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var currentSession, maybeSession, hasExpired, _yield$this$_callRefr, session, error;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return this.initializePromise;\n            case 2:\n              currentSession = null;\n              if (!this.persistSession) {\n                _context10.next = 16;\n                break;\n              }\n              _context10.next = 6;\n              return getItemAsync(this.storage, this.storageKey);\n            case 6:\n              maybeSession = _context10.sent;\n              if (!(maybeSession !== null)) {\n                _context10.next = 14;\n                break;\n              }\n              if (!this._isValidSession(maybeSession)) {\n                _context10.next = 12;\n                break;\n              }\n              currentSession = maybeSession;\n              _context10.next = 14;\n              break;\n            case 12:\n              _context10.next = 14;\n              return this._removeSession();\n            case 14:\n              _context10.next = 17;\n              break;\n            case 16:\n              currentSession = this.inMemorySession;\n            case 17:\n              if (currentSession) {\n                _context10.next = 19;\n                break;\n              }\n              return _context10.abrupt(\"return\", {\n                data: {\n                  session: null\n                },\n                error: null\n              });\n            case 19:\n              hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n              if (hasExpired) {\n                _context10.next = 22;\n                break;\n              }\n              return _context10.abrupt(\"return\", {\n                data: {\n                  session: currentSession\n                },\n                error: null\n              });\n            case 22:\n              _context10.next = 24;\n              return this._callRefreshToken(currentSession.refresh_token);\n            case 24:\n              _yield$this$_callRefr = _context10.sent;\n              session = _yield$this$_callRefr.session;\n              error = _yield$this$_callRefr.error;\n              if (!error) {\n                _context10.next = 29;\n                break;\n              }\n              return _context10.abrupt(\"return\", {\n                data: {\n                  session: null\n                },\n                error: error\n              });\n            case 29:\n              return _context10.abrupt(\"return\", {\n                data: {\n                  session: session\n                },\n                error: null\n              });\n            case 30:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Gets the current user details if there is an existing session.\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n     */\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _yield$this$getSessio, data, error;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.prev = 0;\n              if (jwt) {\n                _context11.next = 10;\n                break;\n              }\n              _context11.next = 4;\n              return this.getSession();\n            case 4:\n              _yield$this$getSessio = _context11.sent;\n              data = _yield$this$getSessio.data;\n              error = _yield$this$getSessio.error;\n              if (!error) {\n                _context11.next = 9;\n                break;\n              }\n              throw error;\n            case 9:\n              // Default to Authorization header if there is no existing session\n              jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n            case 10:\n              _context11.next = 12;\n              return _request(this.fetch, 'GET', \"\".concat(this.url, \"/user\"), {\n                headers: this.headers,\n                jwt: jwt,\n                xform: _userResponse\n              });\n            case 12:\n              return _context11.abrupt(\"return\", _context11.sent);\n            case 15:\n              _context11.prev = 15;\n              _context11.t0 = _context11[\"catch\"](0);\n              if (!isAuthError(_context11.t0)) {\n                _context11.next = 19;\n                break;\n              }\n              return _context11.abrupt(\"return\", {\n                data: {\n                  user: null\n                },\n                error: _context11.t0\n              });\n            case 19:\n              throw _context11.t0;\n            case 20:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this, [[0, 15]]);\n      }));\n    }\n    /**\n     * Updates user data for a logged in user.\n     */\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(attributes) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _yield$this$getSessio2, sessionData, sessionError, session, _yield$_request5, data, userError;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.prev = 0;\n              _context12.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio2 = _context12.sent;\n              sessionData = _yield$this$getSessio2.data;\n              sessionError = _yield$this$getSessio2.error;\n              if (!sessionError) {\n                _context12.next = 8;\n                break;\n              }\n              throw sessionError;\n            case 8:\n              if (sessionData.session) {\n                _context12.next = 10;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 10:\n              session = sessionData.session;\n              _context12.next = 13;\n              return _request(this.fetch, 'PUT', \"\".concat(this.url, \"/user\"), {\n                headers: this.headers,\n                redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                body: attributes,\n                jwt: session.access_token,\n                xform: _userResponse\n              });\n            case 13:\n              _yield$_request5 = _context12.sent;\n              data = _yield$_request5.data;\n              userError = _yield$_request5.error;\n              if (!userError) {\n                _context12.next = 18;\n                break;\n              }\n              throw userError;\n            case 18:\n              session.user = data.user;\n              _context12.next = 21;\n              return this._saveSession(session);\n            case 21:\n              this._notifyAllSubscribers('USER_UPDATED', session);\n              return _context12.abrupt(\"return\", {\n                data: {\n                  user: session.user\n                },\n                error: null\n              });\n            case 25:\n              _context12.prev = 25;\n              _context12.t0 = _context12[\"catch\"](0);\n              if (!isAuthError(_context12.t0)) {\n                _context12.next = 29;\n                break;\n              }\n              return _context12.abrupt(\"return\", {\n                data: {\n                  user: null\n                },\n                error: _context12.t0\n              });\n            case 29:\n              throw _context12.t0;\n            case 30:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this, [[0, 25]]);\n      }));\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */\n  }, {\n    key: \"_decodeJWT\",\n    value: function _decodeJWT(jwt) {\n      return decodeJWTPayload(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n  }, {\n    key: \"setSession\",\n    value: function setSession(currentSession) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var timeNow, expiresAt, hasExpired, session, payload, _yield$this$_callRefr2, refreshedSession, error, _yield$this$getUser, data, _error2;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.prev = 0;\n              if (!(!currentSession.access_token || !currentSession.refresh_token)) {\n                _context13.next = 3;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 3:\n              timeNow = Date.now() / 1000;\n              expiresAt = timeNow;\n              hasExpired = true;\n              session = null;\n              payload = decodeJWTPayload(currentSession.access_token);\n              if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n              }\n              if (!hasExpired) {\n                _context13.next = 22;\n                break;\n              }\n              _context13.next = 12;\n              return this._callRefreshToken(currentSession.refresh_token);\n            case 12:\n              _yield$this$_callRefr2 = _context13.sent;\n              refreshedSession = _yield$this$_callRefr2.session;\n              error = _yield$this$_callRefr2.error;\n              if (!error) {\n                _context13.next = 17;\n                break;\n              }\n              return _context13.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 17:\n              if (refreshedSession) {\n                _context13.next = 19;\n                break;\n              }\n              return _context13.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: null\n              });\n            case 19:\n              session = refreshedSession;\n              _context13.next = 33;\n              break;\n            case 22:\n              _context13.next = 24;\n              return this.getUser(currentSession.access_token);\n            case 24:\n              _yield$this$getUser = _context13.sent;\n              data = _yield$this$getUser.data;\n              _error2 = _yield$this$getUser.error;\n              if (!_error2) {\n                _context13.next = 29;\n                break;\n              }\n              throw _error2;\n            case 29:\n              session = {\n                access_token: currentSession.access_token,\n                refresh_token: currentSession.refresh_token,\n                user: data.user,\n                token_type: 'bearer',\n                expires_in: expiresAt - timeNow,\n                expires_at: expiresAt\n              };\n              _context13.next = 32;\n              return this._saveSession(session);\n            case 32:\n              this._notifyAllSubscribers('SIGNED_IN', session);\n            case 33:\n              return _context13.abrupt(\"return\", {\n                data: {\n                  user: session.user,\n                  session: session\n                },\n                error: null\n              });\n            case 36:\n              _context13.prev = 36;\n              _context13.t0 = _context13[\"catch\"](0);\n              if (!isAuthError(_context13.t0)) {\n                _context13.next = 40;\n                break;\n              }\n              return _context13.abrupt(\"return\", {\n                data: {\n                  session: null,\n                  user: null\n                },\n                error: _context13.t0\n              });\n            case 40:\n              throw _context13.t0;\n            case 41:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this, [[0, 36]]);\n      }));\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession(currentSession) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _yield$this$getSessio3, data, _error3, _yield$this$_callRefr3, session, error;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.prev = 0;\n              if (currentSession) {\n                _context14.next = 10;\n                break;\n              }\n              _context14.next = 4;\n              return this.getSession();\n            case 4:\n              _yield$this$getSessio3 = _context14.sent;\n              data = _yield$this$getSessio3.data;\n              _error3 = _yield$this$getSessio3.error;\n              if (!_error3) {\n                _context14.next = 9;\n                break;\n              }\n              throw _error3;\n            case 9:\n              currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n            case 10:\n              if (currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token) {\n                _context14.next = 12;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 12:\n              _context14.next = 14;\n              return this._callRefreshToken(currentSession.refresh_token);\n            case 14:\n              _yield$this$_callRefr3 = _context14.sent;\n              session = _yield$this$_callRefr3.session;\n              error = _yield$this$_callRefr3.error;\n              if (!error) {\n                _context14.next = 19;\n                break;\n              }\n              return _context14.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 19:\n              if (session) {\n                _context14.next = 21;\n                break;\n              }\n              return _context14.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: null\n              });\n            case 21:\n              return _context14.abrupt(\"return\", {\n                data: {\n                  user: session.user,\n                  session: session\n                },\n                error: null\n              });\n            case 24:\n              _context14.prev = 24;\n              _context14.t0 = _context14[\"catch\"](0);\n              if (!isAuthError(_context14.t0)) {\n                _context14.next = 28;\n                break;\n              }\n              return _context14.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context14.t0\n              });\n            case 28:\n              throw _context14.t0;\n            case 29:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this, [[0, 24]]);\n      }));\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n  }, {\n    key: \"_getSessionFromUrl\",\n    value: function _getSessionFromUrl(isPKCEFlow) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var authCode, _yield$this$exchangeC, _data, _error4, error_description, error_code, _error5, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$getUser2, data, error, user, session, redirectType;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.prev = 0;\n              if (isBrowser()) {\n                _context15.next = 3;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No browser detected.');\n            case 3:\n              if (!(this.flowType === 'implicit' && !this._isImplicitGrantFlow())) {\n                _context15.next = 7;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n            case 7:\n              if (!(this.flowType == 'pkce' && !isPKCEFlow)) {\n                _context15.next = 9;\n                break;\n              }\n              throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n            case 9:\n              if (!isPKCEFlow) {\n                _context15.next = 23;\n                break;\n              }\n              authCode = getParameterByName('code');\n              if (authCode) {\n                _context15.next = 13;\n                break;\n              }\n              throw new AuthPKCEGrantCodeExchangeError('No code detected.');\n            case 13:\n              _context15.next = 15;\n              return this.exchangeCodeForSession(authCode);\n            case 15:\n              _yield$this$exchangeC = _context15.sent;\n              _data = _yield$this$exchangeC.data;\n              _error4 = _yield$this$exchangeC.error;\n              if (!_error4) {\n                _context15.next = 20;\n                break;\n              }\n              throw _error4;\n            case 20:\n              if (_data.session) {\n                _context15.next = 22;\n                break;\n              }\n              throw new AuthPKCEGrantCodeExchangeError('No session detected.');\n            case 22:\n              return _context15.abrupt(\"return\", {\n                data: {\n                  session: _data.session,\n                  redirectType: null\n                },\n                error: null\n              });\n            case 23:\n              error_description = getParameterByName('error_description');\n              if (!error_description) {\n                _context15.next = 32;\n                break;\n              }\n              error_code = getParameterByName('error_code');\n              if (error_code) {\n                _context15.next = 28;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No error_code detected.');\n            case 28:\n              _error5 = getParameterByName('error');\n              if (_error5) {\n                _context15.next = 31;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No error detected.');\n            case 31:\n              throw new AuthImplicitGrantRedirectError(error_description, {\n                error: _error5,\n                code: error_code\n              });\n            case 32:\n              provider_token = getParameterByName('provider_token');\n              provider_refresh_token = getParameterByName('provider_refresh_token');\n              access_token = getParameterByName('access_token');\n              if (access_token) {\n                _context15.next = 37;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No access_token detected.');\n            case 37:\n              expires_in = getParameterByName('expires_in');\n              if (expires_in) {\n                _context15.next = 40;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n            case 40:\n              refresh_token = getParameterByName('refresh_token');\n              if (refresh_token) {\n                _context15.next = 43;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n            case 43:\n              token_type = getParameterByName('token_type');\n              if (token_type) {\n                _context15.next = 46;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No token_type detected.');\n            case 46:\n              timeNow = Math.round(Date.now() / 1000);\n              expires_at = timeNow + parseInt(expires_in);\n              _context15.next = 50;\n              return this.getUser(access_token);\n            case 50:\n              _yield$this$getUser2 = _context15.sent;\n              data = _yield$this$getUser2.data;\n              error = _yield$this$getUser2.error;\n              if (!error) {\n                _context15.next = 55;\n                break;\n              }\n              throw error;\n            case 55:\n              user = data.user;\n              session = {\n                provider_token: provider_token,\n                provider_refresh_token: provider_refresh_token,\n                access_token: access_token,\n                expires_in: parseInt(expires_in),\n                expires_at: expires_at,\n                refresh_token: refresh_token,\n                token_type: token_type,\n                user: user\n              };\n              redirectType = getParameterByName('type'); // Remove tokens from URL\n              window.location.hash = '';\n              return _context15.abrupt(\"return\", {\n                data: {\n                  session: session,\n                  redirectType: redirectType\n                },\n                error: null\n              });\n            case 62:\n              _context15.prev = 62;\n              _context15.t0 = _context15[\"catch\"](0);\n              if (!isAuthError(_context15.t0)) {\n                _context15.next = 66;\n                break;\n              }\n              return _context15.abrupt(\"return\", {\n                data: {\n                  session: null,\n                  redirectType: null\n                },\n                error: _context15.t0\n              });\n            case 66:\n              throw _context15.t0;\n            case 67:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this, [[0, 62]]);\n      }));\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n  }, {\n    key: \"_isImplicitGrantFlow\",\n    value: function _isImplicitGrantFlow() {\n      return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */\n  }, {\n    key: \"_isPKCEFlow\",\n    value: function _isPKCEFlow() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var currentStorageContent;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.next = 2;\n              return getItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            case 2:\n              currentStorageContent = _context16.sent;\n              return _context16.abrupt(\"return\", isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent));\n            case 4:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     */\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var _yield$this$getSessio4, data, sessionError, accessToken, _yield$this$admin$sig, error;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return this.getSession();\n            case 2:\n              _yield$this$getSessio4 = _context17.sent;\n              data = _yield$this$getSessio4.data;\n              sessionError = _yield$this$getSessio4.error;\n              if (!sessionError) {\n                _context17.next = 7;\n                break;\n              }\n              return _context17.abrupt(\"return\", {\n                error: sessionError\n              });\n            case 7:\n              accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n              if (!accessToken) {\n                _context17.next = 16;\n                break;\n              }\n              _context17.next = 11;\n              return this.admin.signOut(accessToken);\n            case 11:\n              _yield$this$admin$sig = _context17.sent;\n              error = _yield$this$admin$sig.error;\n              if (!error) {\n                _context17.next = 16;\n                break;\n              }\n              if (isAuthApiError(error) && (error.status === 404 || error.status === 401)) {\n                _context17.next = 16;\n                break;\n              }\n              return _context17.abrupt(\"return\", {\n                error: error\n              });\n            case 16:\n              _context17.next = 18;\n              return this._removeSession();\n            case 18:\n              _context17.next = 20;\n              return removeItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            case 20:\n              this._notifyAllSubscribers('SIGNED_OUT', null);\n              return _context17.abrupt(\"return\", {\n                error: null\n              });\n            case 22:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this3 = this;\n      var id = uuid();\n      var subscription = {\n        id: id,\n        callback: callback,\n        unsubscribe: function unsubscribe() {\n          _this3.stateChangeEmitters[\"delete\"](id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      this.emitInitialSession(id);\n      return {\n        data: {\n          subscription: subscription\n        }\n      };\n    }\n  }, {\n    key: \"emitInitialSession\",\n    value: function emitInitialSession(id) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var _yield$this$getSessio5, session, error;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.prev = 0;\n              _context18.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio5 = _context18.sent;\n              session = _yield$this$getSessio5.data.session;\n              error = _yield$this$getSessio5.error;\n              if (!error) {\n                _context18.next = 8;\n                break;\n              }\n              throw error;\n            case 8:\n              (_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session);\n              _context18.next = 15;\n              break;\n            case 11:\n              _context18.prev = 11;\n              _context18.t0 = _context18[\"catch\"](0);\n              (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null);\n              console.error(_context18.t0);\n            case 15:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Sends a password reset request to an email address.\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var codeChallenge, codeChallengeMethod, codeVerifier;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              codeChallenge = null;\n              codeChallengeMethod = null;\n              if (!(this.flowType === 'pkce')) {\n                _context19.next = 10;\n                break;\n              }\n              codeVerifier = generatePKCEVerifier();\n              _context19.next = 6;\n              return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n            case 6:\n              _context19.next = 8;\n              return generatePKCEChallenge(codeVerifier);\n            case 8:\n              codeChallenge = _context19.sent;\n              codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n            case 10:\n              _context19.prev = 10;\n              _context19.next = 13;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/recover\"), {\n                body: {\n                  email: email,\n                  code_challenge: codeChallenge,\n                  code_challenge_method: codeChallengeMethod,\n                  gotrue_meta_security: {\n                    captcha_token: options.captchaToken\n                  }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n              });\n            case 13:\n              return _context19.abrupt(\"return\", _context19.sent);\n            case 16:\n              _context19.prev = 16;\n              _context19.t0 = _context19[\"catch\"](10);\n              if (!isAuthError(_context19.t0)) {\n                _context19.next = 20;\n                break;\n              }\n              return _context19.abrupt(\"return\", {\n                data: null,\n                error: _context19.t0\n              });\n            case 20:\n              throw _context19.t0;\n            case 21:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this, [[10, 16]]);\n      }));\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n  }, {\n    key: \"_refreshAccessToken\",\n    value: function _refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var _this4 = this;\n        var startedAt;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.prev = 0;\n              startedAt = Date.now(); // will attempt to refresh the token with exponential backoff\n              _context21.next = 4;\n              return retryable(function (attempt) {\n                return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n                  return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n                    while (1) switch (_context20.prev = _context20.next) {\n                      case 0:\n                        _context20.next = 2;\n                        return sleep(attempt * 200);\n                      case 2:\n                        _context20.next = 4;\n                        return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                          body: {\n                            refresh_token: refreshToken\n                          },\n                          headers: this.headers,\n                          xform: _sessionResponse\n                        });\n                      case 4:\n                        return _context20.abrupt(\"return\", _context20.sent);\n                      case 5:\n                      case \"end\":\n                        return _context20.stop();\n                    }\n                  }, _callee20, this);\n                }));\n              }, function (attempt, _, result) {\n                return result && result.error && result.error instanceof AuthRetryableFetchError &&\n                // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION;\n              });\n            case 4:\n              return _context21.abrupt(\"return\", _context21.sent);\n            case 7:\n              _context21.prev = 7;\n              _context21.t0 = _context21[\"catch\"](0);\n              if (!isAuthError(_context21.t0)) {\n                _context21.next = 11;\n                break;\n              }\n              return _context21.abrupt(\"return\", {\n                data: {\n                  session: null,\n                  user: null\n                },\n                error: _context21.t0\n              });\n            case 11:\n              throw _context21.t0;\n            case 12:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, null, [[0, 7]]);\n      }));\n    }\n  }, {\n    key: \"_isValidSession\",\n    value: function _isValidSession(maybeSession) {\n      var isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n      return isValidSession;\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var url;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.next = 2;\n              return this._getUrlForProvider(provider, {\n                redirectTo: options.redirectTo,\n                scopes: options.scopes,\n                queryParams: options.queryParams\n              });\n            case 2:\n              url = _context22.sent;\n              // try to open on the browser\n              if (isBrowser() && !options.skipBrowserRedirect) {\n                window.location.assign(url);\n              }\n              return _context22.abrupt(\"return\", {\n                data: {\n                  provider: provider,\n                  url: url\n                },\n                error: null\n              });\n            case 5:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var currentSession, timeNow, _yield$this$_callRefr4, error;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.prev = 0;\n              _context23.next = 3;\n              return getItemAsync(this.storage, this.storageKey);\n            case 3:\n              currentSession = _context23.sent;\n              if (this._isValidSession(currentSession)) {\n                _context23.next = 9;\n                break;\n              }\n              if (!(currentSession !== null)) {\n                _context23.next = 8;\n                break;\n              }\n              _context23.next = 8;\n              return this._removeSession();\n            case 8:\n              return _context23.abrupt(\"return\");\n            case 9:\n              timeNow = Math.round(Date.now() / 1000);\n              if (!(((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN)) {\n                _context23.next = 26;\n                break;\n              }\n              if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                _context23.next = 22;\n                break;\n              }\n              _context23.next = 14;\n              return this._callRefreshToken(currentSession.refresh_token);\n            case 14:\n              _yield$this$_callRefr4 = _context23.sent;\n              error = _yield$this$_callRefr4.error;\n              if (!error) {\n                _context23.next = 20;\n                break;\n              }\n              console.log(error.message);\n              _context23.next = 20;\n              return this._removeSession();\n            case 20:\n              _context23.next = 24;\n              break;\n            case 22:\n              _context23.next = 24;\n              return this._removeSession();\n            case 24:\n              _context23.next = 30;\n              break;\n            case 26:\n              if (!this.persistSession) {\n                _context23.next = 29;\n                break;\n              }\n              _context23.next = 29;\n              return this._saveSession(currentSession);\n            case 29:\n              this._notifyAllSubscribers('SIGNED_IN', currentSession);\n            case 30:\n              _context23.next = 36;\n              break;\n            case 32:\n              _context23.prev = 32;\n              _context23.t0 = _context23[\"catch\"](0);\n              console.error(_context23.t0);\n              return _context23.abrupt(\"return\");\n            case 36:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this, [[0, 32]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refreshToken) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        var _yield$this$_refreshA, data, error, result, _result;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              if (!this.refreshingDeferred) {\n                _context24.next = 2;\n                break;\n              }\n              return _context24.abrupt(\"return\", this.refreshingDeferred.promise);\n            case 2:\n              _context24.prev = 2;\n              this.refreshingDeferred = new Deferred();\n              if (refreshToken) {\n                _context24.next = 6;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 6:\n              _context24.next = 8;\n              return this._refreshAccessToken(refreshToken);\n            case 8:\n              _yield$this$_refreshA = _context24.sent;\n              data = _yield$this$_refreshA.data;\n              error = _yield$this$_refreshA.error;\n              if (!error) {\n                _context24.next = 13;\n                break;\n              }\n              throw error;\n            case 13:\n              if (data.session) {\n                _context24.next = 15;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 15:\n              _context24.next = 17;\n              return this._saveSession(data.session);\n            case 17:\n              this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n              result = {\n                session: data.session,\n                error: null\n              };\n              this.refreshingDeferred.resolve(result);\n              return _context24.abrupt(\"return\", result);\n            case 23:\n              _context24.prev = 23;\n              _context24.t0 = _context24[\"catch\"](2);\n              if (!isAuthError(_context24.t0)) {\n                _context24.next = 29;\n                break;\n              }\n              _result = {\n                session: null,\n                error: _context24.t0\n              };\n              (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result);\n              return _context24.abrupt(\"return\", _result);\n            case 29:\n              (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_context24.t0);\n              throw _context24.t0;\n            case 31:\n              _context24.prev = 31;\n              this.refreshingDeferred = null;\n              return _context24.finish(31);\n            case 34:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this, [[2, 23, 31, 34]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event, session) {\n      var broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (this.broadcastChannel && broadcast) {\n        this.broadcastChannel.postMessage({\n          event: event,\n          session: session\n        });\n      }\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, session);\n      });\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              if (!this.persistSession) {\n                this.inMemorySession = session;\n              }\n              if (!(this.persistSession && session.expires_at)) {\n                _context25.next = 4;\n                break;\n              }\n              _context25.next = 4;\n              return this._persistSession(session);\n            case 4:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              if (!this.persistSession) {\n                _context26.next = 5;\n                break;\n              }\n              _context26.next = 3;\n              return removeItemAsync(this.storage, this.storageKey);\n            case 3:\n              _context26.next = 6;\n              break;\n            case 5:\n              this.inMemorySession = null;\n            case 6:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */\n  }, {\n    key: \"_removeVisibilityChangedCallback\",\n    value: function _removeVisibilityChangedCallback() {\n      var callback = this.visibilityChangedCallback;\n      this.visibilityChangedCallback = null;\n      try {\n        if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n          window.removeEventListener('visibilitychange', callback);\n        }\n      } catch (e) {\n        console.error('removing visibilitychange callback failed', e);\n      }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */\n  }, {\n    key: \"_startAutoRefresh\",\n    value: function _startAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var _this5 = this;\n        var ticker;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              _context27.next = 2;\n              return this._stopAutoRefresh();\n            case 2:\n              ticker = setInterval(function () {\n                return _this5._autoRefreshTokenTick();\n              }, AUTO_REFRESH_TICK_DURATION);\n              this.autoRefreshTicker = ticker;\n              if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n                // ticker is a NodeJS Timeout object that has an `unref` method\n                // https://nodejs.org/api/timers.html#timeoutunref\n                // When auto refresh is used in NodeJS (like for testing) the\n                // `setInterval` is preventing the process from being marked as\n                // finished and tests run endlessly. This can be prevented by calling\n                // `unref()` on the returned object.\n                ticker.unref();\n                // @ts-ignore\n              } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n                // similar like for NodeJS, but with the Deno API\n                // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n                // @ts-ignore\n                Deno.unrefTimer(ticker);\n              }\n              // run the tick immediately\n              _context27.next = 7;\n              return this._autoRefreshTokenTick();\n            case 7:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */\n  }, {\n    key: \"_stopAutoRefresh\",\n    value: function _stopAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var ticker;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              ticker = this.autoRefreshTicker;\n              this.autoRefreshTicker = null;\n              if (ticker) {\n                clearInterval(ticker);\n              }\n            case 3:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this);\n      }));\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desireable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */\n  }, {\n    key: \"startAutoRefresh\",\n    value: function startAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              this._removeVisibilityChangedCallback();\n              _context29.next = 3;\n              return this._startAutoRefresh();\n            case 3:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */\n  }, {\n    key: \"stopAutoRefresh\",\n    value: function stopAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              this._removeVisibilityChangedCallback();\n              _context30.next = 3;\n              return this._stopAutoRefresh();\n            case 3:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */\n  }, {\n    key: \"_autoRefreshTokenTick\",\n    value: function _autoRefreshTokenTick() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {\n        var now, _yield$this$getSessio6, session, expiresInTicks;\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) switch (_context31.prev = _context31.next) {\n            case 0:\n              now = Date.now();\n              _context31.prev = 1;\n              _context31.next = 4;\n              return this.getSession();\n            case 4:\n              _yield$this$getSessio6 = _context31.sent;\n              session = _yield$this$getSessio6.data.session;\n              if (!(!session || !session.refresh_token || !session.expires_at)) {\n                _context31.next = 8;\n                break;\n              }\n              return _context31.abrupt(\"return\");\n            case 8:\n              // session will expire in this many ticks (or has already expired if <= 0)\n              expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n              if (!(expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD)) {\n                _context31.next = 12;\n                break;\n              }\n              _context31.next = 12;\n              return this._callRefreshToken(session.refresh_token);\n            case 12:\n              _context31.next = 17;\n              break;\n            case 14:\n              _context31.prev = 14;\n              _context31.t0 = _context31[\"catch\"](1);\n              console.error('Auto refresh tick failed with error. This is likely a transient error.', _context31.t0);\n            case 17:\n            case \"end\":\n              return _context31.stop();\n          }\n        }, _callee31, this, [[1, 14]]);\n      }));\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {\n        var _this6 = this;\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              if (!(!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener))) {\n                _context33.next = 3;\n                break;\n              }\n              if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n              }\n              return _context33.abrupt(\"return\", false);\n            case 3:\n              _context33.prev = 3;\n              this.visibilityChangedCallback = function () {\n                return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n                  return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n                    while (1) switch (_context32.prev = _context32.next) {\n                      case 0:\n                        _context32.next = 2;\n                        return this._onVisibilityChanged(false);\n                      case 2:\n                        return _context32.abrupt(\"return\", _context32.sent);\n                      case 3:\n                      case \"end\":\n                        return _context32.stop();\n                    }\n                  }, _callee32, this);\n                }));\n              };\n              window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);\n              // now immediately call the visbility changed callback to setup with the\n              // current visbility state\n              _context33.next = 8;\n              return this._onVisibilityChanged(true);\n            case 8:\n              _context33.next = 13;\n              break;\n            case 10:\n              _context33.prev = 10;\n              _context33.t0 = _context33[\"catch\"](3);\n              console.error('_handleVisibilityChange', _context33.t0);\n            case 13:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee33, this, [[3, 10]]);\n      }));\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */\n  }, {\n    key: \"_onVisibilityChanged\",\n    value: function _onVisibilityChanged(isInitial) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              if (!(document.visibilityState === 'visible')) {\n                _context34.next = 9;\n                break;\n              }\n              if (isInitial) {\n                _context34.next = 6;\n                break;\n              }\n              _context34.next = 4;\n              return this.initializePromise;\n            case 4:\n              _context34.next = 6;\n              return this._recoverAndRefresh();\n            case 6:\n              if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n              }\n              _context34.next = 10;\n              break;\n            case 9:\n              if (document.visibilityState === 'hidden') {\n                if (this.autoRefreshToken) {\n                  this._stopAutoRefresh();\n                }\n              }\n            case 10:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee34, this);\n      }));\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n  }, {\n    key: \"_getUrlForProvider\",\n    value: function _getUrlForProvider(provider, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {\n        var urlParams, codeVerifier, codeChallenge, codeChallengeMethod, flowParams, query;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n              if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n                urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n              }\n              if (options === null || options === void 0 ? void 0 : options.scopes) {\n                urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n              }\n              if (!(this.flowType === 'pkce')) {\n                _context35.next = 13;\n                break;\n              }\n              codeVerifier = generatePKCEVerifier();\n              _context35.next = 7;\n              return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n            case 7:\n              _context35.next = 9;\n              return generatePKCEChallenge(codeVerifier);\n            case 9:\n              codeChallenge = _context35.sent;\n              codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n              flowParams = new URLSearchParams({\n                code_challenge: \"\".concat(encodeURIComponent(codeChallenge)),\n                code_challenge_method: \"\".concat(encodeURIComponent(codeChallengeMethod))\n              });\n              urlParams.push(flowParams.toString());\n            case 13:\n              if (options === null || options === void 0 ? void 0 : options.queryParams) {\n                query = new URLSearchParams(options.queryParams);\n                urlParams.push(query.toString());\n              }\n              return _context35.abrupt(\"return\", \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&')));\n            case 15:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee35, this);\n      }));\n    }\n  }, {\n    key: \"_unenroll\",\n    value: function _unenroll(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {\n        var _yield$this$getSessio7, sessionData, sessionError;\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) switch (_context36.prev = _context36.next) {\n            case 0:\n              _context36.prev = 0;\n              _context36.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio7 = _context36.sent;\n              sessionData = _yield$this$getSessio7.data;\n              sessionError = _yield$this$getSessio7.error;\n              if (!sessionError) {\n                _context36.next = 8;\n                break;\n              }\n              return _context36.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 8:\n              _context36.next = 10;\n              return _request(this.fetch, 'DELETE', \"\".concat(this.url, \"/factors/\").concat(params.factorId), {\n                headers: this.headers,\n                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n              });\n            case 10:\n              return _context36.abrupt(\"return\", _context36.sent);\n            case 13:\n              _context36.prev = 13;\n              _context36.t0 = _context36[\"catch\"](0);\n              if (!isAuthError(_context36.t0)) {\n                _context36.next = 17;\n                break;\n              }\n              return _context36.abrupt(\"return\", {\n                data: null,\n                error: _context36.t0\n              });\n            case 17:\n              throw _context36.t0;\n            case 18:\n            case \"end\":\n              return _context36.stop();\n          }\n        }, _callee36, this, [[0, 13]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#enroll}\n     */\n  }, {\n    key: \"_enroll\",\n    value: function _enroll(params) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {\n        var _yield$this$getSessio8, sessionData, sessionError, _yield$_request6, data, error;\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) switch (_context37.prev = _context37.next) {\n            case 0:\n              _context37.prev = 0;\n              _context37.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio8 = _context37.sent;\n              sessionData = _yield$this$getSessio8.data;\n              sessionError = _yield$this$getSessio8.error;\n              if (!sessionError) {\n                _context37.next = 8;\n                break;\n              }\n              return _context37.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 8:\n              _context37.next = 10;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors\"), {\n                body: {\n                  friendly_name: params.friendlyName,\n                  factor_type: params.factorType,\n                  issuer: params.issuer\n                },\n                headers: this.headers,\n                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n              });\n            case 10:\n              _yield$_request6 = _context37.sent;\n              data = _yield$_request6.data;\n              error = _yield$_request6.error;\n              if (!error) {\n                _context37.next = 15;\n                break;\n              }\n              return _context37.abrupt(\"return\", {\n                data: null,\n                error: error\n              });\n            case 15:\n              if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                data.totp.qr_code = \"data:image/svg+xml;utf-8,\".concat(data.totp.qr_code);\n              }\n              return _context37.abrupt(\"return\", {\n                data: data,\n                error: null\n              });\n            case 19:\n              _context37.prev = 19;\n              _context37.t0 = _context37[\"catch\"](0);\n              if (!isAuthError(_context37.t0)) {\n                _context37.next = 23;\n                break;\n              }\n              return _context37.abrupt(\"return\", {\n                data: null,\n                error: _context37.t0\n              });\n            case 23:\n              throw _context37.t0;\n            case 24:\n            case \"end\":\n              return _context37.stop();\n          }\n        }, _callee37, this, [[0, 19]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#verify}\n     */\n  }, {\n    key: \"_verify\",\n    value: function _verify(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {\n        var _yield$this$getSessio9, sessionData, sessionError, _yield$_request7, data, error;\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) switch (_context38.prev = _context38.next) {\n            case 0:\n              _context38.prev = 0;\n              _context38.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio9 = _context38.sent;\n              sessionData = _yield$this$getSessio9.data;\n              sessionError = _yield$this$getSessio9.error;\n              if (!sessionError) {\n                _context38.next = 8;\n                break;\n              }\n              return _context38.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 8:\n              _context38.next = 10;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/verify\"), {\n                body: {\n                  code: params.code,\n                  challenge_id: params.challengeId\n                },\n                headers: this.headers,\n                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n              });\n            case 10:\n              _yield$_request7 = _context38.sent;\n              data = _yield$_request7.data;\n              error = _yield$_request7.error;\n              if (!error) {\n                _context38.next = 15;\n                break;\n              }\n              return _context38.abrupt(\"return\", {\n                data: null,\n                error: error\n              });\n            case 15:\n              _context38.next = 17;\n              return this._saveSession(Object.assign({\n                expires_at: Math.round(Date.now() / 1000) + data.expires_in\n              }, data));\n            case 17:\n              this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n              return _context38.abrupt(\"return\", {\n                data: data,\n                error: error\n              });\n            case 21:\n              _context38.prev = 21;\n              _context38.t0 = _context38[\"catch\"](0);\n              if (!isAuthError(_context38.t0)) {\n                _context38.next = 25;\n                break;\n              }\n              return _context38.abrupt(\"return\", {\n                data: null,\n                error: _context38.t0\n              });\n            case 25:\n              throw _context38.t0;\n            case 26:\n            case \"end\":\n              return _context38.stop();\n          }\n        }, _callee38, this, [[0, 21]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#challenge}\n     */\n  }, {\n    key: \"_challenge\",\n    value: function _challenge(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {\n        var _yield$this$getSessio10, sessionData, sessionError;\n        return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n          while (1) switch (_context39.prev = _context39.next) {\n            case 0:\n              _context39.prev = 0;\n              _context39.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio10 = _context39.sent;\n              sessionData = _yield$this$getSessio10.data;\n              sessionError = _yield$this$getSessio10.error;\n              if (!sessionError) {\n                _context39.next = 8;\n                break;\n              }\n              return _context39.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 8:\n              _context39.next = 10;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/challenge\"), {\n                headers: this.headers,\n                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n              });\n            case 10:\n              return _context39.abrupt(\"return\", _context39.sent);\n            case 13:\n              _context39.prev = 13;\n              _context39.t0 = _context39[\"catch\"](0);\n              if (!isAuthError(_context39.t0)) {\n                _context39.next = 17;\n                break;\n              }\n              return _context39.abrupt(\"return\", {\n                data: null,\n                error: _context39.t0\n              });\n            case 17:\n              throw _context39.t0;\n            case 18:\n            case \"end\":\n              return _context39.stop();\n          }\n        }, _callee39, this, [[0, 13]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */\n  }, {\n    key: \"_challengeAndVerify\",\n    value: function _challengeAndVerify(params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {\n        var _yield$this$_challeng, challengeData, challengeError;\n        return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n          while (1) switch (_context40.prev = _context40.next) {\n            case 0:\n              _context40.next = 2;\n              return this._challenge({\n                factorId: params.factorId\n              });\n            case 2:\n              _yield$this$_challeng = _context40.sent;\n              challengeData = _yield$this$_challeng.data;\n              challengeError = _yield$this$_challeng.error;\n              if (!challengeError) {\n                _context40.next = 7;\n                break;\n              }\n              return _context40.abrupt(\"return\", {\n                data: null,\n                error: challengeError\n              });\n            case 7:\n              _context40.next = 9;\n              return this._verify({\n                factorId: params.factorId,\n                challengeId: challengeData.id,\n                code: params.code\n              });\n            case 9:\n              return _context40.abrupt(\"return\", _context40.sent);\n            case 10:\n            case \"end\":\n              return _context40.stop();\n          }\n        }, _callee40, this);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */\n  }, {\n    key: \"_listFactors\",\n    value: function _listFactors() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {\n        var _yield$this$getUser3, user, userError, factors, totp;\n        return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n          while (1) switch (_context41.prev = _context41.next) {\n            case 0:\n              _context41.next = 2;\n              return this.getUser();\n            case 2:\n              _yield$this$getUser3 = _context41.sent;\n              user = _yield$this$getUser3.data.user;\n              userError = _yield$this$getUser3.error;\n              if (!userError) {\n                _context41.next = 7;\n                break;\n              }\n              return _context41.abrupt(\"return\", {\n                data: null,\n                error: userError\n              });\n            case 7:\n              factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n              totp = factors.filter(function (factor) {\n                return factor.factor_type === 'totp' && factor.status === 'verified';\n              });\n              return _context41.abrupt(\"return\", {\n                data: {\n                  all: factors,\n                  totp: totp\n                },\n                error: null\n              });\n            case 10:\n            case \"end\":\n              return _context41.stop();\n          }\n        }, _callee41, this);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */\n  }, {\n    key: \"_getAuthenticatorAssuranceLevel\",\n    value: function _getAuthenticatorAssuranceLevel() {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {\n        var _yield$this$getSessio11, session, sessionError, payload, currentLevel, nextLevel, verifiedFactors, currentAuthenticationMethods;\n        return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n          while (1) switch (_context42.prev = _context42.next) {\n            case 0:\n              _context42.next = 2;\n              return this.getSession();\n            case 2:\n              _yield$this$getSessio11 = _context42.sent;\n              session = _yield$this$getSessio11.data.session;\n              sessionError = _yield$this$getSessio11.error;\n              if (!sessionError) {\n                _context42.next = 7;\n                break;\n              }\n              return _context42.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 7:\n              if (session) {\n                _context42.next = 9;\n                break;\n              }\n              return _context42.abrupt(\"return\", {\n                data: {\n                  currentLevel: null,\n                  nextLevel: null,\n                  currentAuthenticationMethods: []\n                },\n                error: null\n              });\n            case 9:\n              payload = this._decodeJWT(session.access_token);\n              currentLevel = null;\n              if (payload.aal) {\n                currentLevel = payload.aal;\n              }\n              nextLevel = currentLevel;\n              verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(function (factor) {\n                return factor.status === 'verified';\n              })) !== null && _b !== void 0 ? _b : [];\n              if (verifiedFactors.length > 0) {\n                nextLevel = 'aal2';\n              }\n              currentAuthenticationMethods = payload.amr || [];\n              return _context42.abrupt(\"return\", {\n                data: {\n                  currentLevel: currentLevel,\n                  nextLevel: nextLevel,\n                  currentAuthenticationMethods: currentAuthenticationMethods\n                },\n                error: null\n              });\n            case 17:\n            case \"end\":\n              return _context42.stop();\n          }\n        }, _callee42, this);\n      }));\n    }\n  }]);\n  return GoTrueClient;\n}();\nexport { GoTrueClient as default };","map":{"version":3,"sources":["../../src/GoTrueClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthPKCEGrantCodeExchangeError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError, } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep, generatePKCEVerifier, generatePKCEChallenge, } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    storageKey: STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: DEFAULT_HEADERS,\n    flowType: 'implicit',\n};\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3;\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     */\n    constructor(options) {\n        var _a;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the the auth state is known and it's save to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */\n        this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */\n        this.broadcastChannel = null;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.inMemorySession = null;\n        this.storageKey = settings.storageKey;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.storage = settings.storage || localStorageAdapter;\n        this.admin = new GoTrueAdminApi({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch,\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = resolveFetch(settings.fetch);\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n        };\n        if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            }\n            catch (e) {\n                console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n            }\n            (_a = this.broadcastChannel) === null || _a === void 0 ? void 0 : _a.addEventListener('message', (event) => {\n                this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */\n    initialize() {\n        if (!this.initializePromise) {\n            this.initializePromise = this._initialize();\n        }\n        return this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n    _initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.initializePromise) {\n                return this.initializePromise;\n            }\n            try {\n                const isPKCEFlow = yield this._isPKCEFlow();\n                if ((this.detectSessionInUrl && this._isImplicitGrantFlow()) || isPKCEFlow) {\n                    const { data, error } = yield this._getSessionFromUrl(isPKCEFlow);\n                    if (error) {\n                        // failed login attempt via url,\n                        // remove old session as in verifyOtp, signUp and signInWith*\n                        yield this._removeSession();\n                        return { error };\n                    }\n                    const { session, redirectType } = data;\n                    yield this._saveSession(session);\n                    setTimeout(() => {\n                        if (redirectType === 'recovery') {\n                            this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                        }\n                        else {\n                            this._notifyAllSubscribers('SIGNED_IN', session);\n                        }\n                    }, 0);\n                    return { error: null };\n                }\n                // no login attempt via callback url try to recover session from storage\n                yield this._recoverAndRefresh();\n                return { error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { error };\n                }\n                return {\n                    error: new AuthUnknownError('Unexpected error during initialization', error),\n                };\n            }\n            finally {\n                yield this._handleVisibilityChange();\n            }\n        });\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n    signUp(credentials) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                let res;\n                if ('email' in credentials) {\n                    const { email, password, options } = credentials;\n                    let codeChallenge = null;\n                    let codeChallengeMethod = null;\n                    if (this.flowType === 'pkce') {\n                        const codeVerifier = generatePKCEVerifier();\n                        yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n                        codeChallenge = yield generatePKCEChallenge(codeVerifier);\n                        codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n                    }\n                    res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n                        headers: this.headers,\n                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                        body: {\n                            email,\n                            password,\n                            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                            code_challenge: codeChallenge,\n                            code_challenge_method: codeChallengeMethod,\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else if ('phone' in credentials) {\n                    const { phone, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            password,\n                            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : 'sms',\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else {\n                    throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n                }\n                const { data, error } = res;\n                if (error || !data) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                const session = data.session;\n                const user = data.user;\n                if (data.session) {\n                    yield this._saveSession(data.session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                }\n                return { data: { user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */\n    signInWithPassword(credentials) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                let res;\n                if ('email' in credentials) {\n                    const { email, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                        headers: this.headers,\n                        body: {\n                            email,\n                            password,\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else if ('phone' in credentials) {\n                    const { phone, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            password,\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else {\n                    throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n                }\n                const { data, error } = res;\n                if (error || !data)\n                    return { data: { user: null, session: null }, error };\n                if (data.session) {\n                    yield this._saveSession(data.session);\n                    this._notifyAllSubscribers('SIGNED_IN', data.session);\n                }\n                return { data, error };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n    signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._removeSession();\n            return yield this._handleProviderSignIn(credentials.provider, {\n                redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect,\n            });\n        });\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n    exchangeCodeForSession(authCode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const codeVerifier = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n            const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier,\n                },\n                xform: _sessionResponse,\n            });\n            yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n            if (error || !data)\n                return { data: { user: null, session: null }, error };\n            if (data.session) {\n                yield this._saveSession(data.session);\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return { data, error };\n        });\n    }\n    /**\n     * Allows signing in with an ID token issued by certain supported providers.\n     * The ID token is verified for validity and a new session is established.\n     *\n     * @experimental\n     */\n    signInWithIdToken(credentials) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._removeSession();\n            try {\n                const { options, provider, token, nonce } = credentials;\n                const res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n                    headers: this.headers,\n                    body: {\n                        provider,\n                        id_token: token,\n                        nonce,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    xform: _sessionResponse,\n                });\n                const { data, error } = res;\n                if (error || !data)\n                    return { data: { user: null, session: null }, error };\n                if (data.session) {\n                    yield this._saveSession(data.session);\n                    this._notifyAllSubscribers('SIGNED_IN', data.session);\n                }\n                return { data, error };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     */\n    signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                if ('email' in credentials) {\n                    const { email, options } = credentials;\n                    let codeChallenge = null;\n                    let codeChallengeMethod = null;\n                    if (this.flowType === 'pkce') {\n                        const codeVerifier = generatePKCEVerifier();\n                        yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n                        codeChallenge = yield generatePKCEChallenge(codeVerifier);\n                        codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n                    }\n                    const { error } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n                        headers: this.headers,\n                        body: {\n                            email,\n                            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                            code_challenge: codeChallenge,\n                            code_challenge_method: codeChallengeMethod,\n                        },\n                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    });\n                    return { data: { user: null, session: null }, error };\n                }\n                if ('phone' in credentials) {\n                    const { phone, options } = credentials;\n                    const { error } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : 'sms',\n                        },\n                    });\n                    return { data: { user: null, session: null }, error };\n                }\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     */\n    verifyOtp(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n                    headers: this.headers,\n                    body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken } }),\n                    redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                    xform: _sessionResponse,\n                });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw new Error('An error occurred on token verification.');\n                }\n                const session = data.session;\n                const user = data.user;\n                if (session === null || session === void 0 ? void 0 : session.access_token) {\n                    yield this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                }\n                return { data: { user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */\n    signInWithSSO(params) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                return yield _request(this.fetch, 'POST', `${this.url}/sso`, {\n                    body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, ('providerId' in params ? { provider_id: params.providerId } : null)), ('domain' in params ? { domain: params.domain } : null)), { redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined }), (((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken)\n                        ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n                        : null)), { skip_http_redirect: true }),\n                    headers: this.headers,\n                    xform: _ssoResponse,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     */\n    getSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // make sure we've read the session from the url if there is one\n            // save to just await, as long we make sure _initialize() never throws\n            yield this.initializePromise;\n            let currentSession = null;\n            if (this.persistSession) {\n                const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n                if (maybeSession !== null) {\n                    if (this._isValidSession(maybeSession)) {\n                        currentSession = maybeSession;\n                    }\n                    else {\n                        yield this._removeSession();\n                    }\n                }\n            }\n            else {\n                currentSession = this.inMemorySession;\n            }\n            if (!currentSession) {\n                return { data: { session: null }, error: null };\n            }\n            const hasExpired = currentSession.expires_at\n                ? currentSession.expires_at <= Date.now() / 1000\n                : false;\n            if (!hasExpired) {\n                return { data: { session: currentSession }, error: null };\n            }\n            const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return { data: { session: null }, error };\n            }\n            return { data: { session }, error: null };\n        });\n    }\n    /**\n     * Gets the current user details if there is an existing session.\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n     */\n    getUser(jwt) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!jwt) {\n                    const { data, error } = yield this.getSession();\n                    if (error) {\n                        throw error;\n                    }\n                    // Default to Authorization header if there is no existing session\n                    jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n                }\n                return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _userResponse,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates user data for a logged in user.\n     */\n    updateUser(attributes, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                const { data, error: userError } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: attributes,\n                    jwt: session.access_token,\n                    xform: _userResponse,\n                });\n                if (userError)\n                    throw userError;\n                session.user = data.user;\n                yield this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED', session);\n                return { data: { user: session.user }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */\n    _decodeJWT(jwt) {\n        return decodeJWTPayload(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n    setSession(currentSession) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!currentSession.access_token || !currentSession.refresh_token) {\n                    throw new AuthSessionMissingError();\n                }\n                const timeNow = Date.now() / 1000;\n                let expiresAt = timeNow;\n                let hasExpired = true;\n                let session = null;\n                const payload = decodeJWTPayload(currentSession.access_token);\n                if (payload.exp) {\n                    expiresAt = payload.exp;\n                    hasExpired = expiresAt <= timeNow;\n                }\n                if (hasExpired) {\n                    const { session: refreshedSession, error } = yield this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        return { data: { user: null, session: null }, error: error };\n                    }\n                    if (!refreshedSession) {\n                        return { data: { user: null, session: null }, error: null };\n                    }\n                    session = refreshedSession;\n                }\n                else {\n                    const { data, error } = yield this.getUser(currentSession.access_token);\n                    if (error) {\n                        throw error;\n                    }\n                    session = {\n                        access_token: currentSession.access_token,\n                        refresh_token: currentSession.refresh_token,\n                        user: data.user,\n                        token_type: 'bearer',\n                        expires_in: expiresAt - timeNow,\n                        expires_at: expiresAt,\n                    };\n                    yield this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                }\n                return { data: { user: session.user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n    refreshSession(currentSession) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!currentSession) {\n                    const { data, error } = yield this.getSession();\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new AuthSessionMissingError();\n                }\n                const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                if (!session) {\n                    return { data: { user: null, session: null }, error: null };\n                }\n                return { data: { user: session.user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n    _getSessionFromUrl(isPKCEFlow) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new AuthImplicitGrantRedirectError('No browser detected.');\n                if (this.flowType === 'implicit' && !this._isImplicitGrantFlow()) {\n                    throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n                }\n                else if (this.flowType == 'pkce' && !isPKCEFlow) {\n                    throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n                }\n                if (isPKCEFlow) {\n                    const authCode = getParameterByName('code');\n                    if (!authCode)\n                        throw new AuthPKCEGrantCodeExchangeError('No code detected.');\n                    const { data, error } = yield this.exchangeCodeForSession(authCode);\n                    if (error)\n                        throw error;\n                    if (!data.session)\n                        throw new AuthPKCEGrantCodeExchangeError('No session detected.');\n                    return { data: { session: data.session, redirectType: null }, error: null };\n                }\n                const error_description = getParameterByName('error_description');\n                if (error_description) {\n                    const error_code = getParameterByName('error_code');\n                    if (!error_code)\n                        throw new AuthImplicitGrantRedirectError('No error_code detected.');\n                    const error = getParameterByName('error');\n                    if (!error)\n                        throw new AuthImplicitGrantRedirectError('No error detected.');\n                    throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code });\n                }\n                const provider_token = getParameterByName('provider_token');\n                const provider_refresh_token = getParameterByName('provider_refresh_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new AuthImplicitGrantRedirectError('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new AuthImplicitGrantRedirectError('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { data, error } = yield this.getUser(access_token);\n                if (error)\n                    throw error;\n                const user = data.user;\n                const session = {\n                    provider_token,\n                    provider_refresh_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user,\n                };\n                const redirectType = getParameterByName('type');\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: { session, redirectType }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, redirectType: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n    _isImplicitGrantFlow() {\n        return (isBrowser() &&\n            (Boolean(getParameterByName('access_token')) ||\n                Boolean(getParameterByName('error_description'))));\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */\n    _isPKCEFlow() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentStorageContent = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n            return isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent);\n        });\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data, error: sessionError } = yield this.getSession();\n            if (sessionError) {\n                return { error: sessionError };\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = yield this.admin.signOut(accessToken);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n                        return { error };\n                    }\n                }\n            }\n            yield this._removeSession();\n            yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n            this._notifyAllSubscribers('SIGNED_OUT', null);\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n    onAuthStateChange(callback) {\n        const id = uuid();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: () => {\n                this.stateChangeEmitters.delete(id);\n            },\n        };\n        this.stateChangeEmitters.set(id, subscription);\n        this.emitInitialSession(id);\n        return { data: { subscription } };\n    }\n    emitInitialSession(id) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: { session }, error, } = yield this.getSession();\n                if (error)\n                    throw error;\n                (_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session);\n            }\n            catch (err) {\n                (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address.\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n    resetPasswordForEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === 'pkce') {\n                const codeVerifier = generatePKCEVerifier();\n                yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n                codeChallenge = yield generatePKCEChallenge(codeVerifier);\n                codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n            }\n            try {\n                return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n                    body: {\n                        email,\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod,\n                        gotrue_meta_security: { captcha_token: options.captchaToken },\n                    },\n                    headers: this.headers,\n                    redirectTo: options.redirectTo,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n    _refreshAccessToken(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const startedAt = Date.now();\n                // will attempt to refresh the token with exponential backoff\n                return yield retryable((attempt) => __awaiter(this, void 0, void 0, function* () {\n                    yield sleep(attempt * 200); // 0, 200, 400, 800, ...\n                    return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n                        body: { refresh_token: refreshToken },\n                        headers: this.headers,\n                        xform: _sessionResponse,\n                    });\n                }), (attempt, _, result) => result &&\n                    result.error &&\n                    result.error instanceof AuthRetryableFetchError &&\n                    // retryable only if the request can be sent before the backoff overflows the tick duration\n                    Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION);\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === 'object' &&\n            maybeSession !== null &&\n            'access_token' in maybeSession &&\n            'refresh_token' in maybeSession &&\n            'expires_at' in maybeSession;\n        return isValidSession;\n    }\n    _handleProviderSignIn(provider, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = yield this._getUrlForProvider(provider, {\n                redirectTo: options.redirectTo,\n                scopes: options.scopes,\n                queryParams: options.queryParams,\n            });\n            // try to open on the browser\n            if (isBrowser() && !options.skipBrowserRedirect) {\n                window.location.assign(url);\n            }\n            return { data: { provider, url }, error: null };\n        });\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const currentSession = yield getItemAsync(this.storage, this.storageKey);\n                if (!this._isValidSession(currentSession)) {\n                    if (currentSession !== null) {\n                        yield this._removeSession();\n                    }\n                    return;\n                }\n                const timeNow = Math.round(Date.now() / 1000);\n                if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            yield this._removeSession();\n                        }\n                    }\n                    else {\n                        yield this._removeSession();\n                    }\n                }\n                else {\n                    if (this.persistSession) {\n                        yield this._saveSession(currentSession);\n                    }\n                    this._notifyAllSubscribers('SIGNED_IN', currentSession);\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return;\n            }\n        });\n    }\n    _callRefreshToken(refreshToken) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            // refreshing is already in progress\n            if (this.refreshingDeferred) {\n                return this.refreshingDeferred.promise;\n            }\n            try {\n                this.refreshingDeferred = new Deferred();\n                if (!refreshToken) {\n                    throw new AuthSessionMissingError();\n                }\n                const { data, error } = yield this._refreshAccessToken(refreshToken);\n                if (error)\n                    throw error;\n                if (!data.session)\n                    throw new AuthSessionMissingError();\n                yield this._saveSession(data.session);\n                this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n                const result = { session: data.session, error: null };\n                this.refreshingDeferred.resolve(result);\n                return result;\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    const result = { session: null, error };\n                    (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                    return result;\n                }\n                (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n                throw error;\n            }\n            finally {\n                this.refreshingDeferred = null;\n            }\n        });\n    }\n    _notifyAllSubscribers(event, session, broadcast = true) {\n        if (this.broadcastChannel && broadcast) {\n            this.broadcastChannel.postMessage({ event, session });\n        }\n        this.stateChangeEmitters.forEach((x) => x.callback(event, session));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.persistSession) {\n                this.inMemorySession = session;\n            }\n            if (this.persistSession && session.expires_at) {\n                yield this._persistSession(session);\n            }\n        });\n    }\n    _persistSession(currentSession) {\n        return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.persistSession) {\n                yield removeItemAsync(this.storage, this.storageKey);\n            }\n            else {\n                this.inMemorySession = null;\n            }\n        });\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */\n    _removeVisibilityChangedCallback() {\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener('visibilitychange', callback);\n            }\n        }\n        catch (e) {\n            console.error('removing visibilitychange callback failed', e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */\n    _startAutoRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._stopAutoRefresh();\n            const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);\n            this.autoRefreshTicker = ticker;\n            if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n                // ticker is a NodeJS Timeout object that has an `unref` method\n                // https://nodejs.org/api/timers.html#timeoutunref\n                // When auto refresh is used in NodeJS (like for testing) the\n                // `setInterval` is preventing the process from being marked as\n                // finished and tests run endlessly. This can be prevented by calling\n                // `unref()` on the returned object.\n                ticker.unref();\n                // @ts-ignore\n            }\n            else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n                // similar like for NodeJS, but with the Deno API\n                // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n                // @ts-ignore\n                Deno.unrefTimer(ticker);\n            }\n            // run the tick immediately\n            yield this._autoRefreshTokenTick();\n        });\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */\n    _stopAutoRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ticker = this.autoRefreshTicker;\n            this.autoRefreshTicker = null;\n            if (ticker) {\n                clearInterval(ticker);\n            }\n        });\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desireable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */\n    startAutoRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._removeVisibilityChangedCallback();\n            yield this._startAutoRefresh();\n        });\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */\n    stopAutoRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._removeVisibilityChangedCallback();\n            yield this._stopAutoRefresh();\n        });\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */\n    _autoRefreshTokenTick() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = Date.now();\n            try {\n                const { data: { session }, } = yield this.getSession();\n                if (!session || !session.refresh_token || !session.expires_at) {\n                    return;\n                }\n                // session will expire in this many ticks (or has already expired if <= 0)\n                const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n                if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n                    yield this._callRefreshToken(session.refresh_token);\n                }\n            }\n            catch (e) {\n                console.error('Auto refresh tick failed with error. This is likely a transient error.', e);\n            }\n        });\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */\n    _handleVisibilityChange() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n                if (this.autoRefreshToken) {\n                    // in non-browser environments the refresh token ticker runs always\n                    this.startAutoRefresh();\n                }\n                return false;\n            }\n            try {\n                this.visibilityChangedCallback = () => __awaiter(this, void 0, void 0, function* () { return yield this._onVisibilityChanged(false); });\n                window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);\n                // now immediately call the visbility changed callback to setup with the\n                // current visbility state\n                yield this._onVisibilityChanged(true); // initial call\n            }\n            catch (error) {\n                console.error('_handleVisibilityChange', error);\n            }\n        });\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */\n    _onVisibilityChanged(isInitial) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (document.visibilityState === 'visible') {\n                if (!isInitial) {\n                    // initial visibility change setup is handled in another flow under #initialize()\n                    yield this.initializePromise;\n                    yield this._recoverAndRefresh();\n                }\n                if (this.autoRefreshToken) {\n                    // in browser environments the refresh token ticker runs only on focused tabs\n                    // which prevents race conditions\n                    this._startAutoRefresh();\n                }\n            }\n            else if (document.visibilityState === 'hidden') {\n                if (this.autoRefreshToken) {\n                    this._stopAutoRefresh();\n                }\n            }\n        });\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n    _getUrlForProvider(provider, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const urlParams = [`provider=${encodeURIComponent(provider)}`];\n            if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n                urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n            }\n            if (options === null || options === void 0 ? void 0 : options.scopes) {\n                urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n            }\n            if (this.flowType === 'pkce') {\n                const codeVerifier = generatePKCEVerifier();\n                yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n                const codeChallenge = yield generatePKCEChallenge(codeVerifier);\n                const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n                const flowParams = new URLSearchParams({\n                    code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                    code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\n                });\n                urlParams.push(flowParams.toString());\n            }\n            if (options === null || options === void 0 ? void 0 : options.queryParams) {\n                const query = new URLSearchParams(options.queryParams);\n                urlParams.push(query.toString());\n            }\n            return `${this.url}/authorize?${urlParams.join('&')}`;\n        });\n    }\n    _unenroll(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                return yield _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#enroll}\n     */\n    _enroll(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/factors`, {\n                    body: {\n                        friendly_name: params.friendlyName,\n                        factor_type: params.factorType,\n                        issuer: params.issuer,\n                    },\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n                if (error) {\n                    return { data: null, error };\n                }\n                if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#verify}\n     */\n    _verify(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n                    body: { code: params.code, challenge_id: params.challengeId },\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n                if (error) {\n                    return { data: null, error };\n                }\n                yield this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1000) + data.expires_in }, data));\n                this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n                return { data, error };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challenge}\n     */\n    _challenge(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                return yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */\n    _challengeAndVerify(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: challengeData, error: challengeError } = yield this._challenge({\n                factorId: params.factorId,\n            });\n            if (challengeError) {\n                return { data: null, error: challengeError };\n            }\n            return yield this._verify({\n                factorId: params.factorId,\n                challengeId: challengeData.id,\n                code: params.code,\n            });\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */\n    _listFactors() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: { user }, error: userError, } = yield this.getUser();\n            if (userError) {\n                return { data: null, error: userError };\n            }\n            const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n            const totp = factors.filter((factor) => factor.factor_type === 'totp' && factor.status === 'verified');\n            return {\n                data: {\n                    all: factors,\n                    totp,\n                },\n                error: null,\n            };\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */\n    _getAuthenticatorAssuranceLevel() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: { session }, error: sessionError, } = yield this.getSession();\n            if (sessionError) {\n                return { data: null, error: sessionError };\n            }\n            if (!session) {\n                return {\n                    data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n                    error: null,\n                };\n            }\n            const payload = this._decodeJWT(session.access_token);\n            let currentLevel = null;\n            if (payload.aal) {\n                currentLevel = payload.aal;\n            }\n            let nextLevel = currentLevel;\n            const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n            if (verifiedFactors.length > 0) {\n                nextLevel = 'aal2';\n            }\n            const currentAuthenticationMethods = payload.amr || [];\n            return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };\n        });\n    }\n}\n//# sourceMappingURL=GoTrueClient.js.map"]},"metadata":{},"sourceType":"module"}