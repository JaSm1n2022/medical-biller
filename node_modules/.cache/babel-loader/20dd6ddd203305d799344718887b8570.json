{"ast":null,"code":"import _slicedToArray from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport PostgrestQueryBuilder from './PostgrestQueryBuilder';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nimport { DEFAULT_HEADERS } from './constants';\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nvar PostgrestClient = /*#__PURE__*/function () {\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  function PostgrestClient(url) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$headers = _ref.headers,\n      headers = _ref$headers === void 0 ? {} : _ref$headers,\n      schema = _ref.schema,\n      fetch = _ref.fetch;\n    _classCallCheck(this, PostgrestClient);\n    this.url = url;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  _createClass(PostgrestClient, [{\n    key: \"from\",\n    value: function from(relation) {\n      var url = new URL(\"\".concat(this.url, \"/\").concat(relation));\n      return new PostgrestQueryBuilder(url, {\n        headers: Object.assign({}, this.headers),\n        schema: this.schema,\n        fetch: this.fetch\n      });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n  }, {\n    key: \"rpc\",\n    value: function rpc(fn) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$head = _ref2.head,\n        head = _ref2$head === void 0 ? false : _ref2$head,\n        count = _ref2.count;\n      var method;\n      var url = new URL(\"\".concat(this.url, \"/rpc/\").concat(fn));\n      var body;\n      if (head) {\n        method = 'HEAD';\n        Object.entries(args).forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            name = _ref4[0],\n            value = _ref4[1];\n          url.searchParams.append(name, \"\".concat(value));\n        });\n      } else {\n        method = 'POST';\n        body = args;\n      }\n      var headers = Object.assign({}, this.headers);\n      if (count) {\n        headers['Prefer'] = \"count=\".concat(count);\n      }\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: url,\n        headers: headers,\n        schema: this.schema,\n        body: body,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n  }]);\n  return PostgrestClient;\n}();\nexport { PostgrestClient as default };","map":{"version":3,"sources":["../../src/PostgrestClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import PostgrestQueryBuilder from './PostgrestQueryBuilder';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nimport { DEFAULT_HEADERS } from './constants';\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient {\n    // TODO: Add back shouldThrowOnError once we figure out the typings\n    /**\n     * Creates a PostgREST client.\n     *\n     * @param url - URL of the PostgREST endpoint\n     * @param options - Named parameters\n     * @param options.headers - Custom headers\n     * @param options.schema - Postgres schema to switch to\n     * @param options.fetch - Custom fetch\n     */\n    constructor(url, { headers = {}, schema, fetch, } = {}) {\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n        this.schema = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */\n    from(relation) {\n        const url = new URL(`${this.url}/${relation}`);\n        return new PostgrestQueryBuilder(url, {\n            headers: Object.assign({}, this.headers),\n            schema: this.schema,\n            fetch: this.fetch,\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    rpc(fn, args = {}, { head = false, count, } = {}) {\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        if (head) {\n            method = 'HEAD';\n            Object.entries(args).forEach(([name, value]) => {\n                url.searchParams.append(name, `${value}`);\n            });\n        }\n        else {\n            method = 'POST';\n            body = args;\n        }\n        const headers = Object.assign({}, this.headers);\n        if (count) {\n            headers['Prefer'] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n}\n//# sourceMappingURL=PostgrestClient.js.map"]},"metadata":{},"sourceType":"module"}