{"ast":null,"code":"import _slicedToArray from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder';\nvar PostgrestFilterBuilder = /*#__PURE__*/function (_PostgrestTransformBu) {\n  _inherits(PostgrestFilterBuilder, _PostgrestTransformBu);\n  var _super = _createSuper(PostgrestFilterBuilder);\n  function PostgrestFilterBuilder() {\n    _classCallCheck(this, PostgrestFilterBuilder);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PostgrestFilterBuilder, [{\n    key: \"eq\",\n    value:\n    /**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    function eq(column, value) {\n      this.url.searchParams.append(column, \"eq.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"neq\",\n    value: function neq(column, value) {\n      this.url.searchParams.append(column, \"neq.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"gt\",\n    value: function gt(column, value) {\n      this.url.searchParams.append(column, \"gt.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"gte\",\n    value: function gte(column, value) {\n      this.url.searchParams.append(column, \"gte.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"lt\",\n    value: function lt(column, value) {\n      this.url.searchParams.append(column, \"lt.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"lte\",\n    value: function lte(column, value) {\n      this.url.searchParams.append(column, \"lte.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n  }, {\n    key: \"like\",\n    value: function like(column, pattern) {\n      this.url.searchParams.append(column, \"like.\".concat(pattern));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n  }, {\n    key: \"likeAllOf\",\n    value: function likeAllOf(column, patterns) {\n      this.url.searchParams.append(column, \"like(all).{\".concat(patterns.join(','), \"}\"));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n  }, {\n    key: \"likeAnyOf\",\n    value: function likeAnyOf(column, patterns) {\n      this.url.searchParams.append(column, \"like(any).{\".concat(patterns.join(','), \"}\"));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n  }, {\n    key: \"ilike\",\n    value: function ilike(column, pattern) {\n      this.url.searchParams.append(column, \"ilike.\".concat(pattern));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n  }, {\n    key: \"ilikeAllOf\",\n    value: function ilikeAllOf(column, patterns) {\n      this.url.searchParams.append(column, \"ilike(all).{\".concat(patterns.join(','), \"}\"));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n  }, {\n    key: \"ilikeAnyOf\",\n    value: function ilikeAnyOf(column, patterns) {\n      this.url.searchParams.append(column, \"ilike(any).{\".concat(patterns.join(','), \"}\"));\n      return this;\n    }\n    /**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"is\",\n    value: function is(column, value) {\n      this.url.searchParams.append(column, \"is.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */\n  }, {\n    key: \"in\",\n    value: function _in(column, values) {\n      var cleanedValues = values.map(function (s) {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return \"\\\"\".concat(s, \"\\\"\");else return \"\".concat(s);\n      }).join(',');\n      this.url.searchParams.append(column, \"in.(\".concat(cleanedValues, \")\"));\n      return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(column, value) {\n      if (typeof value === 'string') {\n        // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n        // keep it simple and accept a string\n        this.url.searchParams.append(column, \"cs.\".concat(value));\n      } else if (Array.isArray(value)) {\n        // array\n        this.url.searchParams.append(column, \"cs.{\".concat(value.join(','), \"}\"));\n      } else {\n        // json\n        this.url.searchParams.append(column, \"cs.\".concat(JSON.stringify(value)));\n      }\n      return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n  }, {\n    key: \"containedBy\",\n    value: function containedBy(column, value) {\n      if (typeof value === 'string') {\n        // range\n        this.url.searchParams.append(column, \"cd.\".concat(value));\n      } else if (Array.isArray(value)) {\n        // array\n        this.url.searchParams.append(column, \"cd.{\".concat(value.join(','), \"}\"));\n      } else {\n        // json\n        this.url.searchParams.append(column, \"cd.\".concat(JSON.stringify(value)));\n      }\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeGt\",\n    value: function rangeGt(column, range) {\n      this.url.searchParams.append(column, \"sr.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeGte\",\n    value: function rangeGte(column, range) {\n      this.url.searchParams.append(column, \"nxl.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeLt\",\n    value: function rangeLt(column, range) {\n      this.url.searchParams.append(column, \"sl.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeLte\",\n    value: function rangeLte(column, range) {\n      this.url.searchParams.append(column, \"nxr.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeAdjacent\",\n    value: function rangeAdjacent(column, range) {\n      this.url.searchParams.append(column, \"adj.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(column, value) {\n      if (typeof value === 'string') {\n        // range\n        this.url.searchParams.append(column, \"ov.\".concat(value));\n      } else {\n        // array\n        this.url.searchParams.append(column, \"ov.{\".concat(value.join(','), \"}\"));\n      }\n      return this;\n    }\n    /**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */\n  }, {\n    key: \"textSearch\",\n    value: function textSearch(column, query) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        config = _ref.config,\n        type = _ref.type;\n      var typePart = '';\n      if (type === 'plain') {\n        typePart = 'pl';\n      } else if (type === 'phrase') {\n        typePart = 'ph';\n      } else if (type === 'websearch') {\n        typePart = 'w';\n      }\n      var configPart = config === undefined ? '' : \"(\".concat(config, \")\");\n      this.url.searchParams.append(column, \"\".concat(typePart, \"fts\").concat(configPart, \".\").concat(query));\n      return this;\n    }\n    /**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */\n  }, {\n    key: \"match\",\n    value: function match(query) {\n      var _this = this;\n      Object.entries(query).forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n          column = _ref3[0],\n          value = _ref3[1];\n        _this.url.searchParams.append(column, \"eq.\".concat(value));\n      });\n      return this;\n    }\n    /**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n  }, {\n    key: \"not\",\n    value: function not(column, operator, value) {\n      this.url.searchParams.append(column, \"not.\".concat(operator, \".\").concat(value));\n      return this;\n    }\n    /**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param foreignTable - Set this to filter on foreign tables instead of the\n     * current table\n     */\n  }, {\n    key: \"or\",\n    value: function or(filters) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        foreignTable = _ref4.foreignTable;\n      var key = foreignTable ? \"\".concat(foreignTable, \".or\") : 'or';\n      this.url.searchParams.append(key, \"(\".concat(filters, \")\"));\n      return this;\n    }\n    /**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(column, operator, value) {\n      this.url.searchParams.append(column, \"\".concat(operator, \".\").concat(value));\n      return this;\n    }\n  }]);\n  return PostgrestFilterBuilder;\n}(PostgrestTransformBuilder);\nexport { PostgrestFilterBuilder as default };","map":{"version":3,"sources":["../../src/PostgrestFilterBuilder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import PostgrestTransformBuilder from './PostgrestTransformBuilder';\nexport default class PostgrestFilterBuilder extends PostgrestTransformBuilder {\n    /**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n    like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n    ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */\n    in(column, values) {\n        const cleanedValues = values\n            .map((s) => {\n            // handle postgrest reserved characters\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n            if (typeof s === 'string' && new RegExp('[,()]').test(s))\n                return `\"${s}\"`;\n            else\n                return `${s}`;\n        })\n            .join(',');\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n    contains(column, value) {\n        if (typeof value === 'string') {\n            // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n            // keep it simple and accept a string\n            this.url.searchParams.append(column, `cs.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cs.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n    containedBy(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(column, `cd.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cd.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */\n    overlaps(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(column, `ov.${value}`);\n        }\n        else {\n            // array\n            this.url.searchParams.append(column, `ov.{${value.join(',')}}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */\n    textSearch(column, query, { config, type } = {}) {\n        let typePart = '';\n        if (type === 'plain') {\n            typePart = 'pl';\n        }\n        else if (type === 'phrase') {\n            typePart = 'ph';\n        }\n        else if (type === 'websearch') {\n            typePart = 'w';\n        }\n        const configPart = config === undefined ? '' : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */\n    match(query) {\n        Object.entries(query).forEach(([column, value]) => {\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n    not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param foreignTable - Set this to filter on foreign tables instead of the\n     * current table\n     */\n    or(filters, { foreignTable } = {}) {\n        const key = foreignTable ? `${foreignTable}.or` : 'or';\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n    filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n}\n//# sourceMappingURL=PostgrestFilterBuilder.js.map"]},"metadata":{},"sourceType":"module"}