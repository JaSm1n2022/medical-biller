{"ast":null,"code":"import _regeneratorRuntime from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { DEFAULT_HEADERS } from '../lib/constants';\nimport { isStorageError } from '../lib/errors';\nimport { get, post, put, remove } from '../lib/fetch';\nimport { resolveFetch } from '../lib/helpers';\nvar StorageBucketApi = /*#__PURE__*/function () {\n  function StorageBucketApi(url) {\n    var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var fetch = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, StorageBucketApi);\n    this.url = url;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Retrieves the details of all Storage buckets within an existing project.\n   */\n  _createClass(StorageBucketApi, [{\n    key: \"listBuckets\",\n    value: function listBuckets() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return get(this.fetch, \"\".concat(this.url, \"/bucket\"), {\n                headers: this.headers\n              });\n            case 3:\n              data = _context.sent;\n              return _context.abrupt(\"return\", {\n                data: data,\n                error: null\n              });\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              if (!isStorageError(_context.t0)) {\n                _context.next = 11;\n                break;\n              }\n              return _context.abrupt(\"return\", {\n                data: null,\n                error: _context.t0\n              });\n            case 11:\n              throw _context.t0;\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */\n  }, {\n    key: \"getBucket\",\n    value: function getBucket(id) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return get(this.fetch, \"\".concat(this.url, \"/bucket/\").concat(id), {\n                headers: this.headers\n              });\n            case 3:\n              data = _context2.sent;\n              return _context2.abrupt(\"return\", {\n                data: data,\n                error: null\n              });\n            case 7:\n              _context2.prev = 7;\n              _context2.t0 = _context2[\"catch\"](0);\n              if (!isStorageError(_context2.t0)) {\n                _context2.next = 11;\n                break;\n              }\n              return _context2.abrupt(\"return\", {\n                data: null,\n                error: _context2.t0\n              });\n            case 11:\n              throw _context2.t0;\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     * @returns newly created bucket id\n     */\n  }, {\n    key: \"createBucket\",\n    value: function createBucket(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        \"public\": false\n      };\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.next = 3;\n              return post(this.fetch, \"\".concat(this.url, \"/bucket\"), {\n                id: id,\n                name: id,\n                \"public\": options[\"public\"],\n                file_size_limit: options.fileSizeLimit,\n                allowed_mime_types: options.allowedMimeTypes\n              }, {\n                headers: this.headers\n              });\n            case 3:\n              data = _context3.sent;\n              return _context3.abrupt(\"return\", {\n                data: data,\n                error: null\n              });\n            case 7:\n              _context3.prev = 7;\n              _context3.t0 = _context3[\"catch\"](0);\n              if (!isStorageError(_context3.t0)) {\n                _context3.next = 11;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                data: null,\n                error: _context3.t0\n              });\n            case 11:\n              throw _context3.t0;\n            case 12:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Updates a Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     */\n  }, {\n    key: \"updateBucket\",\n    value: function updateBucket(id, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.prev = 0;\n              _context4.next = 3;\n              return put(this.fetch, \"\".concat(this.url, \"/bucket/\").concat(id), {\n                id: id,\n                name: id,\n                \"public\": options[\"public\"],\n                file_size_limit: options.fileSizeLimit,\n                allowed_mime_types: options.allowedMimeTypes\n              }, {\n                headers: this.headers\n              });\n            case 3:\n              data = _context4.sent;\n              return _context4.abrupt(\"return\", {\n                data: data,\n                error: null\n              });\n            case 7:\n              _context4.prev = 7;\n              _context4.t0 = _context4[\"catch\"](0);\n              if (!isStorageError(_context4.t0)) {\n                _context4.next = 11;\n                break;\n              }\n              return _context4.abrupt(\"return\", {\n                data: null,\n                error: _context4.t0\n              });\n            case 11:\n              throw _context4.t0;\n            case 12:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */\n  }, {\n    key: \"emptyBucket\",\n    value: function emptyBucket(id) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.prev = 0;\n              _context5.next = 3;\n              return post(this.fetch, \"\".concat(this.url, \"/bucket/\").concat(id, \"/empty\"), {}, {\n                headers: this.headers\n              });\n            case 3:\n              data = _context5.sent;\n              return _context5.abrupt(\"return\", {\n                data: data,\n                error: null\n              });\n            case 7:\n              _context5.prev = 7;\n              _context5.t0 = _context5[\"catch\"](0);\n              if (!isStorageError(_context5.t0)) {\n                _context5.next = 11;\n                break;\n              }\n              return _context5.abrupt(\"return\", {\n                data: null,\n                error: _context5.t0\n              });\n            case 11:\n              throw _context5.t0;\n            case 12:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */\n  }, {\n    key: \"deleteBucket\",\n    value: function deleteBucket(id) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.prev = 0;\n              _context6.next = 3;\n              return remove(this.fetch, \"\".concat(this.url, \"/bucket/\").concat(id), {}, {\n                headers: this.headers\n              });\n            case 3:\n              data = _context6.sent;\n              return _context6.abrupt(\"return\", {\n                data: data,\n                error: null\n              });\n            case 7:\n              _context6.prev = 7;\n              _context6.t0 = _context6[\"catch\"](0);\n              if (!isStorageError(_context6.t0)) {\n                _context6.next = 11;\n                break;\n              }\n              return _context6.abrupt(\"return\", {\n                data: null,\n                error: _context6.t0\n              });\n            case 11:\n              throw _context6.t0;\n            case 12:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[0, 7]]);\n      }));\n    }\n  }]);\n  return StorageBucketApi;\n}();\nexport { StorageBucketApi as default };","map":{"version":3,"sources":["../../../src/packages/StorageBucketApi.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DEFAULT_HEADERS } from '../lib/constants';\nimport { isStorageError } from '../lib/errors';\nimport { get, post, put, remove } from '../lib/fetch';\nimport { resolveFetch } from '../lib/helpers';\nexport default class StorageBucketApi {\n    constructor(url, headers = {}, fetch) {\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */\n    listBuckets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */\n    getBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     * @returns newly created bucket id\n     */\n    createBucket(id, options = {\n        public: false,\n    }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/bucket`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates a Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     */\n    updateBucket(id, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */\n    emptyBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */\n    deleteBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=StorageBucketApi.js.map"]},"metadata":{},"sourceType":"module"}