{"ast":null,"code":"import _regeneratorRuntime from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nvar noop = function noop() {};\nvar RealtimeClient = /*#__PURE__*/function () {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  function RealtimeClient(endPoint, options) {\n    var _this = this;\n    _classCallCheck(this, RealtimeClient);\n    var _a;\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    var eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(function () {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.disconnect();\n              this.connect();\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }, this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  _createClass(RealtimeClient, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n      if (this.conn) {\n        return;\n      }\n      this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n      if (this.conn) {\n        this.conn.binaryType = 'arraybuffer';\n        this.conn.onopen = function () {\n          return _this2._onConnOpen();\n        };\n        this.conn.onerror = function (error) {\n          return _this2._onConnError(error);\n        };\n        this.conn.onmessage = function (event) {\n          return _this2._onConnMessage(event);\n        };\n        this.conn.onclose = function (event) {\n          return _this2._onConnClose(event);\n        };\n      }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n        // remove open handles\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.reset();\n      }\n    }\n    /**\n     * Returns all created channels\n     */\n  }, {\n    key: \"getChannels\",\n    value: function getChannels() {\n      return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n  }, {\n    key: \"removeChannel\",\n    value: function removeChannel(channel) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var status;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return channel.unsubscribe();\n            case 2:\n              status = _context2.sent;\n              if (this.channels.length === 0) {\n                this.disconnect();\n              }\n              return _context2.abrupt(\"return\", status);\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n  }, {\n    key: \"removeAllChannels\",\n    value: function removeAllChannels() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var values_1;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return Promise.all(this.channels.map(function (channel) {\n                return channel.unsubscribe();\n              }));\n            case 2:\n              values_1 = _context3.sent;\n              this.disconnect();\n              return _context3.abrupt(\"return\", values_1);\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return CONNECTION_STATE.Connecting;\n        case SOCKET_STATES.open:\n          return CONNECTION_STATE.Open;\n        case SOCKET_STATES.closing:\n          return CONNECTION_STATE.Closing;\n        default:\n          return CONNECTION_STATE.Closed;\n      }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === CONNECTION_STATE.Open;\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        config: {}\n      };\n      if (!this.isConnected()) {\n        this.connect();\n      }\n      var chan = new RealtimeChannel(\"realtime:\".concat(topic), params, this);\n      this.channels.push(chan);\n      return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this3 = this;\n      var topic = data.topic,\n        event = data.event,\n        payload = data.payload,\n        ref = data.ref;\n      var callback = function callback() {\n        _this3.encode(data, function (result) {\n          var _a;\n          (_a = _this3.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n        });\n      };\n      this.log('push', \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n      if (this.isConnected()) {\n        if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n          var isThrottled = this._throttle(callback)();\n          if (isThrottled) {\n            return 'rate limited';\n          }\n        } else {\n          callback();\n        }\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(token) {\n      this.accessToken = token;\n      this.channels.forEach(function (channel) {\n        token && channel.updateJoinPayload({\n          access_token: token\n        });\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: token\n          });\n        }\n      });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n  }, {\n    key: \"_makeRef\",\n    value: function _makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n      return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_leaveOpenTopic\",\n    value: function _leaveOpenTopic(topic) {\n      var dupChannel = this.channels.find(function (c) {\n        return c.topic === topic && (c._isJoined() || c._isJoining());\n      });\n      if (dupChannel) {\n        this.log('transport', \"leaving duplicate topic \\\"\".concat(topic, \"\\\"\"));\n        dupChannel.unsubscribe();\n      }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_remove\",\n    value: function _remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c._joinRef() !== channel._joinRef();\n      });\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_endPointURL\",\n    value: function _endPointURL() {\n      return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnMessage\",\n    value: function _onConnMessage(rawMessage) {\n      var _this4 = this;\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n          event = msg.event,\n          payload = msg.payload,\n          ref = msg.ref;\n        if (ref && ref === _this4.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n          _this4.pendingHeartbeatRef = null;\n        }\n        _this4.log('receive', \"\".concat(payload.status || '', \" \").concat(topic, \" \").concat(event, \" \").concat(ref && '(' + ref + ')' || ''), payload);\n        _this4.channels.filter(function (channel) {\n          return channel._isMember(topic);\n        }).forEach(function (channel) {\n          return channel._trigger(event, payload, ref);\n        });\n        _this4.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnOpen\",\n    value: function _onConnOpen() {\n      var _this5 = this;\n      this.log('transport', \"connected to \".concat(this._endPointURL()));\n      this._flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(function () {\n        return _this5._sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnClose\",\n    value: function _onConnClose(event) {\n      this.log('transport', 'close', event);\n      this._triggerChanError();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnError\",\n    value: function _onConnError(error) {\n      this.log('transport', error.message);\n      this._triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_triggerChanError\",\n    value: function _triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel._trigger(CHANNEL_EVENTS.error);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_appendParams\",\n    value: function _appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n      var prefix = url.match(/\\?/) ? '&' : '?';\n      var query = new URLSearchParams(params);\n      return \"\".concat(url).concat(prefix).concat(query);\n    }\n    /** @internal */\n  }, {\n    key: \"_flushSendBuffer\",\n    value: function _flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_sendHeartbeat\",\n    value: function _sendHeartbeat() {\n      var _a;\n      if (!this.isConnected()) {\n        return;\n      }\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n      this.pendingHeartbeatRef = this._makeRef();\n      this.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.setAuth(this.accessToken);\n    }\n    /** @internal */\n  }, {\n    key: \"_throttle\",\n    value: function _throttle(callback) {\n      var _this6 = this;\n      var eventsPerSecondLimitMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.eventsPerSecondLimitMs;\n      return function () {\n        if (_this6.inThrottle) return true;\n        callback();\n        if (eventsPerSecondLimitMs > 0) {\n          _this6.inThrottle = true;\n          setTimeout(function () {\n            _this6.inThrottle = false;\n          }, eventsPerSecondLimitMs);\n        }\n        return false;\n      };\n    }\n  }]);\n  return RealtimeClient;\n}();\nexport { RealtimeClient as default };","map":{"version":3,"sources":["../../src/RealtimeClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE, } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessToken = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.transport = w3cwebsocket;\n        this.heartbeatIntervalMs = 30000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.eventsPerSecondLimitMs = 100;\n        this.inThrottle = false;\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.transport)\n            this.transport = options.transport;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n        if (eventsPerSecond)\n            this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs)\n            ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode)\n            ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode)\n            ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n            this.disconnect();\n            this.connect();\n        }), this.reconnectAfterMs);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n        if (this.conn) {\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this._onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function () { }; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    removeChannel(channel) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const status = yield channel.unsubscribe();\n            if (this.channels.length === 0) {\n                this.disconnect();\n            }\n            return status;\n        });\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    removeAllChannels() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values_1 = yield Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n            this.disconnect();\n            return values_1;\n        });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    channel(topic, params = { config: {} }) {\n        if (!this.isConnected()) {\n            this.connect();\n        }\n        const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        let callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n                const isThrottled = this._throttle(callback)();\n                if (isThrottled) {\n                    return 'rate limited';\n                }\n            }\n            else {\n                callback();\n            }\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n    setAuth(token) {\n        this.accessToken = token;\n        this.channels.forEach((channel) => {\n            token && channel.updateJoinPayload({ access_token: token });\n            if (channel.joinedOnce && channel._isJoined()) {\n                channel._push(CHANNEL_EVENTS.access_token, { access_token: token });\n            }\n        });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n    _endPointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if ((ref && ref === this.pendingHeartbeatRef) ||\n                event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /** @internal */\n    _onConnOpen() {\n        this.log('transport', `connected to ${this._endPointURL()}`);\n        this._flushSendBuffer();\n        this.reconnectTimer.reset();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    /** @internal */\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    /** @internal */\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    /** @internal */\n    _flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /** @internal */\n    _sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth(this.accessToken);\n    }\n    /** @internal */\n    _throttle(callback, eventsPerSecondLimitMs = this.eventsPerSecondLimitMs) {\n        return () => {\n            if (this.inThrottle)\n                return true;\n            callback();\n            if (eventsPerSecondLimitMs > 0) {\n                this.inThrottle = true;\n                setTimeout(() => {\n                    this.inThrottle = false;\n                }, eventsPerSecondLimitMs);\n            }\n            return false;\n        };\n    }\n}\n//# sourceMappingURL=RealtimeClient.js.map"]},"metadata":{},"sourceType":"module"}