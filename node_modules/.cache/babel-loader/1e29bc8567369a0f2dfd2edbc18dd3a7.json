{"ast":null,"code":"import _toConsumableArray from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nargelmac/Documents/GitHub/medical-biller/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nvar PostgrestQueryBuilder = /*#__PURE__*/function () {\n  function PostgrestQueryBuilder(url, _ref) {\n    var _ref$headers = _ref.headers,\n      headers = _ref$headers === void 0 ? {} : _ref$headers,\n      schema = _ref.schema,\n      fetch = _ref.fetch;\n    _classCallCheck(this, PostgrestQueryBuilder);\n    this.url = url;\n    this.headers = headers;\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  _createClass(PostgrestQueryBuilder, [{\n    key: \"select\",\n    value: function select(columns) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$head = _ref2.head,\n        head = _ref2$head === void 0 ? false : _ref2$head,\n        count = _ref2.count;\n      var method = head ? 'HEAD' : 'GET';\n      // Remove whitespaces except when quoted\n      var quoted = false;\n      var cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(function (c) {\n        if (/\\s/.test(c) && !quoted) {\n          return '';\n        }\n        if (c === '\"') {\n          quoted = !quoted;\n        }\n        return c;\n      }).join('');\n      this.url.searchParams.set('select', cleanedColumns);\n      if (count) {\n        this.headers['Prefer'] = \"count=\".concat(count);\n      }\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n    /**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column.\n     */\n  }, {\n    key: \"insert\",\n    value: function insert(values) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        count = _ref3.count,\n        _ref3$defaultToNull = _ref3.defaultToNull,\n        defaultToNull = _ref3$defaultToNull === void 0 ? true : _ref3$defaultToNull;\n      var method = 'POST';\n      var prefersHeaders = [];\n      if (this.headers['Prefer']) {\n        prefersHeaders.push(this.headers['Prefer']);\n      }\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n      if (!defaultToNull) {\n        prefersHeaders.push('missing=default');\n      }\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      if (Array.isArray(values)) {\n        var columns = values.reduce(function (acc, x) {\n          return acc.concat(Object.keys(x));\n        }, []);\n        if (columns.length > 0) {\n          var uniqueColumns = _toConsumableArray(new Set(columns)).map(function (column) {\n            return \"\\\"\".concat(column, \"\\\"\");\n          });\n          this.url.searchParams.set('columns', uniqueColumns.join(','));\n        }\n      }\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        body: values,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n    /**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`.\n     */\n  }, {\n    key: \"upsert\",\n    value: function upsert(values) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        onConflict = _ref4.onConflict,\n        _ref4$ignoreDuplicate = _ref4.ignoreDuplicates,\n        ignoreDuplicates = _ref4$ignoreDuplicate === void 0 ? false : _ref4$ignoreDuplicate,\n        count = _ref4.count,\n        _ref4$defaultToNull = _ref4.defaultToNull,\n        defaultToNull = _ref4$defaultToNull === void 0 ? true : _ref4$defaultToNull;\n      var method = 'POST';\n      var prefersHeaders = [\"resolution=\".concat(ignoreDuplicates ? 'ignore' : 'merge', \"-duplicates\")];\n      if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n      if (this.headers['Prefer']) {\n        prefersHeaders.push(this.headers['Prefer']);\n      }\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n      if (!defaultToNull) {\n        prefersHeaders.push('missing=default');\n      }\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      if (Array.isArray(values)) {\n        var columns = values.reduce(function (acc, x) {\n          return acc.concat(Object.keys(x));\n        }, []);\n        if (columns.length > 0) {\n          var uniqueColumns = _toConsumableArray(new Set(columns)).map(function (column) {\n            return \"\\\"\".concat(column, \"\\\"\");\n          });\n          this.url.searchParams.set('columns', uniqueColumns.join(','));\n        }\n      }\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        body: values,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n    /**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n  }, {\n    key: \"update\",\n    value: function update(values) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        count = _ref5.count;\n      var method = 'PATCH';\n      var prefersHeaders = [];\n      if (this.headers['Prefer']) {\n        prefersHeaders.push(this.headers['Prefer']);\n      }\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        body: values,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n    /**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        count = _ref6.count;\n      var method = 'DELETE';\n      var prefersHeaders = [];\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n      if (this.headers['Prefer']) {\n        prefersHeaders.unshift(this.headers['Prefer']);\n      }\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n  }]);\n  return PostgrestQueryBuilder;\n}();\nexport { PostgrestQueryBuilder as default };","map":{"version":3,"sources":["../../src/PostgrestQueryBuilder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestQueryBuilder {\n    constructor(url, { headers = {}, schema, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.schema = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a SELECT query on the table or view.\n     *\n     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n     *\n     * @param options - Named parameters\n     *\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     *\n     * @param options.count - Count algorithm to use to count rows in the table or view.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    select(columns, { head = false, count, } = {}) {\n        const method = head ? 'HEAD' : 'GET';\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (count) {\n            this.headers['Prefer'] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column.\n     */\n    insert(values, { count, defaultToNull = true, } = {}) {\n        const method = 'POST';\n        const prefersHeaders = [];\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push('missing=default');\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`.\n     */\n    upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true, } = {}) {\n        const method = 'POST';\n        const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];\n        if (onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push('missing=default');\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    update(values, { count, } = {}) {\n        const method = 'PATCH';\n        const prefersHeaders = [];\n        if (this.headers['Prefer']) {\n            prefersHeaders.push(this.headers['Prefer']);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n    /**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    delete({ count, } = {}) {\n        const method = 'DELETE';\n        const prefersHeaders = [];\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers['Prefer']) {\n            prefersHeaders.unshift(this.headers['Prefer']);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false,\n        });\n    }\n}\n//# sourceMappingURL=PostgrestQueryBuilder.js.map"]},"metadata":{},"sourceType":"module"}